// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to PipeWire API
class PipeWire {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  PipeWire(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  PipeWire.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// The entry point in a plugin.
  ///
  /// \param factory a location to hold the factory result
  /// \param index index to keep track of the enumeration
  /// \return 1 on success
  /// 0 when no more items are available
  /// < 0 errno type error
  int spa_handle_factory_enum(
    ffi.Pointer<ffi.Pointer<spa_handle_factory>> factory$,
    ffi.Pointer<ffi.Uint32> index,
  ) {
    return _spa_handle_factory_enum(
      factory$,
      index,
    );
  }

  late final _spa_handle_factory_enumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<spa_handle_factory>>,
              ffi.Pointer<ffi.Uint32>)>>('spa_handle_factory_enum');
  late final _spa_handle_factory_enum = _spa_handle_factory_enumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<spa_handle_factory>>,
          ffi.Pointer<ffi.Uint32>)>();

  /// Update an existing \ref pw_core_info with \a update with reset
  ffi.Pointer<pw_core_info> pw_core_info_update(
    ffi.Pointer<pw_core_info> info,
    ffi.Pointer<pw_core_info> update,
  ) {
    return _pw_core_info_update(
      info,
      update,
    );
  }

  late final _pw_core_info_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core_info> Function(ffi.Pointer<pw_core_info>,
              ffi.Pointer<pw_core_info>)>>('pw_core_info_update');
  late final _pw_core_info_update = _pw_core_info_updatePtr.asFunction<
      ffi.Pointer<pw_core_info> Function(
          ffi.Pointer<pw_core_info>, ffi.Pointer<pw_core_info>)>();

  /// Update an existing \ref pw_core_info with \a update
  ffi.Pointer<pw_core_info> pw_core_info_merge(
    ffi.Pointer<pw_core_info> info,
    ffi.Pointer<pw_core_info> update,
    bool reset,
  ) {
    return _pw_core_info_merge(
      info,
      update,
      reset,
    );
  }

  late final _pw_core_info_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core_info> Function(ffi.Pointer<pw_core_info>,
              ffi.Pointer<pw_core_info>, ffi.Bool)>>('pw_core_info_merge');
  late final _pw_core_info_merge = _pw_core_info_mergePtr.asFunction<
      ffi.Pointer<pw_core_info> Function(
          ffi.Pointer<pw_core_info>, ffi.Pointer<pw_core_info>, bool)>();

  /// Free a \ref pw_core_info
  void pw_core_info_free(
    ffi.Pointer<pw_core_info> info,
  ) {
    return _pw_core_info_free(
      info,
    );
  }

  late final _pw_core_info_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_core_info>)>>(
          'pw_core_info_free');
  late final _pw_core_info_free = _pw_core_info_freePtr
      .asFunction<void Function(ffi.Pointer<pw_core_info>)>();

  /// Connect to a PipeWire instance
  ///
  /// \param context a \ref pw_context
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error. The core
  /// will have an id of \ref PW_ID_CORE (0)
  ffi.Pointer<pw_core> pw_context_connect(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect(
      context,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_connect');
  late final _pw_context_connect = _pw_context_connectPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>, int)>();

  /// Connect to a PipeWire instance on the given socket
  ///
  /// \param context a \ref pw_context
  /// \param fd the connected socket to use, the socket will be closed
  /// automatically on disconnect or error.
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error
  ffi.Pointer<pw_core> pw_context_connect_fd(
    ffi.Pointer<pw_context> context,
    int fd,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect_fd(
      context,
      fd,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connect_fdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(ffi.Pointer<pw_context>, ffi.Int,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_connect_fd');
  late final _pw_context_connect_fd = _pw_context_connect_fdPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, int, ffi.Pointer<pw_properties>, int)>();

  /// Connect to a given PipeWire instance
  ///
  /// \param context a \ref pw_context to connect to
  /// \param properties optional properties, ownership of the properties is
  /// taken.
  /// \param user_data_size extra user data size
  ///
  /// \return a \ref pw_core on success or NULL with errno set on error
  ffi.Pointer<pw_core> pw_context_connect_self(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> properties,
    int user_data_size,
  ) {
    return _pw_context_connect_self(
      context,
      properties,
      user_data_size,
    );
  }

  late final _pw_context_connect_selfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<pw_properties>,
              ffi.Size)>>('pw_context_connect_self');
  late final _pw_context_connect_self = _pw_context_connect_selfPtr.asFunction<
      ffi.Pointer<pw_core> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>, int)>();

  /// Steal the fd of the core connection or < 0 on error. The core
  /// will be disconnected after this call.
  int pw_core_steal_fd(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_steal_fd(
      core,
    );
  }

  late final _pw_core_steal_fdPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>)>>(
          'pw_core_steal_fd');
  late final _pw_core_steal_fd =
      _pw_core_steal_fdPtr.asFunction<int Function(ffi.Pointer<pw_core>)>();

  /// Pause or resume the core. When the core is paused, no new events
  /// will be dispatched until the core is resumed again.
  int pw_core_set_paused(
    ffi.Pointer<pw_core> core,
    bool paused,
  ) {
    return _pw_core_set_paused(
      core,
      paused,
    );
  }

  late final _pw_core_set_pausedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>, ffi.Bool)>>(
      'pw_core_set_paused');
  late final _pw_core_set_paused = _pw_core_set_pausedPtr
      .asFunction<int Function(ffi.Pointer<pw_core>, bool)>();

  /// disconnect and destroy a core
  int pw_core_disconnect(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_disconnect(
      core,
    );
  }

  late final _pw_core_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_core>)>>(
          'pw_core_disconnect');
  late final _pw_core_disconnect =
      _pw_core_disconnectPtr.asFunction<int Function(ffi.Pointer<pw_core>)>();

  /// Get the user_data. It is of the size specified when this object was
  /// constructed
  ffi.Pointer<ffi.Void> pw_core_get_user_data(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_user_data(
      core,
    );
  }

  late final _pw_core_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_user_data');
  late final _pw_core_get_user_data = _pw_core_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_core>)>();

  /// Get the client proxy of the connected core. This will have the id
  /// of PW_ID_CLIENT (1)
  ffi.Pointer<pw_client> pw_core_get_client(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_client(
      core,
    );
  }

  late final _pw_core_get_clientPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_client> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_client');
  late final _pw_core_get_client = _pw_core_get_clientPtr
      .asFunction<ffi.Pointer<pw_client> Function(ffi.Pointer<pw_core>)>();

  /// Get the context object used to created this core
  ffi.Pointer<pw_context> pw_core_get_context(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_context(
      core,
    );
  }

  late final _pw_core_get_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_context');
  late final _pw_core_get_context = _pw_core_get_contextPtr
      .asFunction<ffi.Pointer<pw_context> Function(ffi.Pointer<pw_core>)>();

  /// Get properties from the core
  ffi.Pointer<pw_properties> pw_core_get_properties(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_properties(
      core,
    );
  }

  late final _pw_core_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_properties');
  late final _pw_core_get_properties = _pw_core_get_propertiesPtr
      .asFunction<ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_core>)>();

  /// Update the core properties. This updates the properties
  /// of the associated client.
  /// \return the number of properties that were updated
  int pw_core_update_properties(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_core_update_properties(
      core,
      dict,
    );
  }

  late final _pw_core_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_core>,
              ffi.Pointer<spa_dict>)>>('pw_core_update_properties');
  late final _pw_core_update_properties = _pw_core_update_propertiesPtr
      .asFunction<int Function(ffi.Pointer<pw_core>, ffi.Pointer<spa_dict>)>();

  /// Get the core mempool object
  ffi.Pointer<pw_mempool> pw_core_get_mempool(
    ffi.Pointer<pw_core> core,
  ) {
    return _pw_core_get_mempool(
      core,
    );
  }

  late final _pw_core_get_mempoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_mempool> Function(
              ffi.Pointer<pw_core>)>>('pw_core_get_mempool');
  late final _pw_core_get_mempool = _pw_core_get_mempoolPtr
      .asFunction<ffi.Pointer<pw_mempool> Function(ffi.Pointer<pw_core>)>();

  /// Get the proxy with the given id
  ffi.Pointer<pw_proxy> pw_core_find_proxy(
    ffi.Pointer<pw_core> core,
    int id,
  ) {
    return _pw_core_find_proxy(
      core,
      id,
    );
  }

  late final _pw_core_find_proxyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core>, ffi.Uint32)>>('pw_core_find_proxy');
  late final _pw_core_find_proxy = _pw_core_find_proxyPtr
      .asFunction<ffi.Pointer<pw_proxy> Function(ffi.Pointer<pw_core>, int)>();

  /// Export an object into the PipeWire instance associated with core
  ffi.Pointer<pw_proxy> pw_core_export(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<spa_dict> props,
    ffi.Pointer<ffi.Void> object,
    int user_data_size,
  ) {
    return _pw_core_export(
      core,
      type,
      props,
      object,
      user_data_size,
    );
  }

  late final _pw_core_exportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('pw_core_export');
  late final _pw_core_export = _pw_core_exportPtr.asFunction<
      ffi.Pointer<pw_proxy> Function(
          ffi.Pointer<pw_core>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<spa_dict>,
          ffi.Pointer<ffi.Void>,
          int)>();

  /// Make a new context object for a given main_loop. Ownership of the properties is taken
  ffi.Pointer<pw_context> pw_context_new(
    ffi.Pointer<pw_loop> main_loop,
    ffi.Pointer<pw_properties> props,
    int user_data_size,
  ) {
    return _pw_context_new(
      main_loop,
      props,
      user_data_size,
    );
  }

  late final _pw_context_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(ffi.Pointer<pw_loop>,
              ffi.Pointer<pw_properties>, ffi.Size)>>('pw_context_new');
  late final _pw_context_new = _pw_context_newPtr.asFunction<
      ffi.Pointer<pw_context> Function(
          ffi.Pointer<pw_loop>, ffi.Pointer<pw_properties>, int)>();

  /// destroy a context object, all resources except the main_loop will be destroyed
  void pw_context_destroy(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_destroy(
      context,
    );
  }

  late final _pw_context_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_context>)>>(
          'pw_context_destroy');
  late final _pw_context_destroy = _pw_context_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_context>)>();

  /// Get the context user data
  ffi.Pointer<ffi.Void> pw_context_get_user_data(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_user_data(
      context,
    );
  }

  late final _pw_context_get_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_user_data');
  late final _pw_context_get_user_data = _pw_context_get_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_context>)>();

  /// Add a new event listener to a context
  void pw_context_add_listener(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_context_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_add_listener(
      context,
      listener,
      events,
      data,
    );
  }

  late final _pw_context_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_context_events>,
              ffi.Pointer<ffi.Void>)>>('pw_context_add_listener');
  late final _pw_context_add_listener = _pw_context_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_context>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_context_events>, ffi.Pointer<ffi.Void>)>();

  /// Get the context properties
  ffi.Pointer<pw_properties> pw_context_get_properties(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_properties(
      context,
    );
  }

  late final _pw_context_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_properties');
  late final _pw_context_get_properties =
      _pw_context_get_propertiesPtr.asFunction<
          ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_context>)>();

  /// Update the context properties
  int pw_context_update_properties(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_context_update_properties(
      context,
      dict,
    );
  }

  late final _pw_context_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>,
              ffi.Pointer<spa_dict>)>>('pw_context_update_properties');
  late final _pw_context_update_properties =
      _pw_context_update_propertiesPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<spa_dict>)>();

  /// Get a config section for this context. Since 0.3.22, deprecated,
  /// use pw_context_conf_section_for_each().
  ffi.Pointer<ffi.Char> pw_context_get_conf_section(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
  ) {
    return _pw_context_get_conf_section(
      context,
      section,
    );
  }

  late final _pw_context_get_conf_sectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_get_conf_section');
  late final _pw_context_get_conf_section =
      _pw_context_get_conf_sectionPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// Parse a standard config section for this context. Since 0.3.22
  int pw_context_parse_conf_section(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_properties> conf,
    ffi.Pointer<ffi.Char> section,
  ) {
    return _pw_context_parse_conf_section(
      context,
      conf,
      section,
    );
  }

  late final _pw_context_parse_conf_sectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>)>>('pw_context_parse_conf_section');
  late final _pw_context_parse_conf_section =
      _pw_context_parse_conf_sectionPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_properties>,
              ffi.Pointer<ffi.Char>)>();

  /// update properties from a section into props. Since 0.3.45
  int pw_context_conf_update_props(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_context_conf_update_props(
      context,
      section,
      props,
    );
  }

  late final _pw_context_conf_update_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>>('pw_context_conf_update_props');
  late final _pw_context_conf_update_props =
      _pw_context_conf_update_propsPtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>();

  /// emit callback for all config sections. Since 0.3.45
  int pw_context_conf_section_for_each(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> data,
                    ffi.Pointer<ffi.Char> location,
                    ffi.Pointer<ffi.Char> section,
                    ffi.Pointer<ffi.Char> str,
                    ffi.Size len)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_conf_section_for_each(
      context,
      section,
      callback,
      data,
    );
  }

  late final _pw_context_conf_section_for_eachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<ffi.Char> location,
                          ffi.Pointer<ffi.Char> section,
                          ffi.Pointer<ffi.Char> str,
                          ffi.Size len)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_conf_section_for_each');
  late final _pw_context_conf_section_for_each =
      _pw_context_conf_section_for_eachPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<ffi.Char> location,
                          ffi.Pointer<ffi.Char> section,
                          ffi.Pointer<ffi.Char> str,
                          ffi.Size len)>>,
              ffi.Pointer<ffi.Void>)>();

  /// emit callback for all matched properties. Since 0.3.46
  int pw_context_conf_section_match_rules(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> section,
    ffi.Pointer<spa_dict> props,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> data,
                    ffi.Pointer<ffi.Char> location,
                    ffi.Pointer<ffi.Char> action,
                    ffi.Pointer<ffi.Char> str,
                    ffi.Size len)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_conf_section_match_rules(
      context,
      section,
      props,
      callback,
      data,
    );
  }

  late final _pw_context_conf_section_match_rulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<ffi.Char> location,
                          ffi.Pointer<ffi.Char> action,
                          ffi.Pointer<ffi.Char> str,
                          ffi.Size len)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_conf_section_match_rules');
  late final _pw_context_conf_section_match_rules =
      _pw_context_conf_section_match_rulesPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<ffi.Char> location,
                          ffi.Pointer<ffi.Char> action,
                          ffi.Pointer<ffi.Char> str,
                          ffi.Size len)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Get the context support objects
  ffi.Pointer<spa_support> pw_context_get_support(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Uint32> n_support,
  ) {
    return _pw_context_get_support(
      context,
      n_support,
    );
  }

  late final _pw_context_get_supportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_support> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Uint32>)>>('pw_context_get_support');
  late final _pw_context_get_support = _pw_context_get_supportPtr.asFunction<
      ffi.Pointer<spa_support> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Uint32>)>();

  /// get the context main loop
  ffi.Pointer<pw_loop> pw_context_get_main_loop(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_main_loop(
      context,
    );
  }

  late final _pw_context_get_main_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_main_loop');
  late final _pw_context_get_main_loop = _pw_context_get_main_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_context>)>();

  /// Get the work queue from the context: Since 0.3.26
  ffi.Pointer<pw_work_queue> pw_context_get_work_queue(
    ffi.Pointer<pw_context> context,
  ) {
    return _pw_context_get_work_queue(
      context,
    );
  }

  late final _pw_context_get_work_queuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_work_queue> Function(
              ffi.Pointer<pw_context>)>>('pw_context_get_work_queue');
  late final _pw_context_get_work_queue =
      _pw_context_get_work_queuePtr.asFunction<
          ffi.Pointer<pw_work_queue> Function(ffi.Pointer<pw_context>)>();

  /// Iterate the globals of the context. The callback should return
  /// 0 to fetch the next item, any other value stops the iteration and returns
  /// the value. When all callbacks return 0, this function returns 0 when all
  /// globals are iterated.
  int pw_context_for_each_global(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> data, ffi.Pointer<pw_global> global)>>
        callback,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_context_for_each_global(
      context,
      callback,
      data,
    );
  }

  late final _pw_context_for_each_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<pw_global> global)>>,
              ffi.Pointer<ffi.Void>)>>('pw_context_for_each_global');
  late final _pw_context_for_each_global =
      _pw_context_for_each_globalPtr.asFunction<
          int Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> data,
                          ffi.Pointer<pw_global> global)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Find a context global by id
  ffi.Pointer<pw_global> pw_context_find_global(
    ffi.Pointer<pw_context> context,
    int id,
  ) {
    return _pw_context_find_global(
      context,
      id,
    );
  }

  late final _pw_context_find_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_global> Function(
              ffi.Pointer<pw_context>, ffi.Uint32)>>('pw_context_find_global');
  late final _pw_context_find_global = _pw_context_find_globalPtr.asFunction<
      ffi.Pointer<pw_global> Function(ffi.Pointer<pw_context>, int)>();

  /// add a spa library for the given factory_name regex
  int pw_context_add_spa_lib(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_regex,
    ffi.Pointer<ffi.Char> lib,
  ) {
    return _pw_context_add_spa_lib(
      context,
      factory_regex,
      lib,
    );
  }

  late final _pw_context_add_spa_libPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_context_add_spa_lib');
  late final _pw_context_add_spa_lib = _pw_context_add_spa_libPtr.asFunction<
      int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// find the library name for a spa factory
  ffi.Pointer<ffi.Char> pw_context_find_spa_lib(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_name,
  ) {
    return _pw_context_find_spa_lib(
      context,
      factory_name,
    );
  }

  late final _pw_context_find_spa_libPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_find_spa_lib');
  late final _pw_context_find_spa_lib = _pw_context_find_spa_libPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<spa_handle> pw_context_load_spa_handle(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> factory_name,
    ffi.Pointer<spa_dict> info,
  ) {
    return _pw_context_load_spa_handle(
      context,
      factory_name,
      info,
    );
  }

  late final _pw_context_load_spa_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_handle> Function(
              ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>)>>('pw_context_load_spa_handle');
  late final _pw_context_load_spa_handle =
      _pw_context_load_spa_handlePtr.asFunction<
          ffi.Pointer<spa_handle> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<spa_dict>)>();

  /// register a type that can be exported on a context_proxy. This is usually used by
  /// extension modules
  int pw_context_register_export_type(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<pw_export_type> type,
  ) {
    return _pw_context_register_export_type(
      context,
      type,
    );
  }

  late final _pw_context_register_export_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>,
              ffi.Pointer<pw_export_type>)>>('pw_context_register_export_type');
  late final _pw_context_register_export_type =
      _pw_context_register_export_typePtr.asFunction<
          int Function(ffi.Pointer<pw_context>, ffi.Pointer<pw_export_type>)>();

  /// find information about registered export type
  ffi.Pointer<pw_export_type> pw_context_find_export_type(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _pw_context_find_export_type(
      context,
      type,
    );
  }

  late final _pw_context_find_export_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_export_type> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_find_export_type');
  late final _pw_context_find_export_type =
      _pw_context_find_export_typePtr.asFunction<
          ffi.Pointer<pw_export_type> Function(
              ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// add an object to the context
  int pw_context_set_object(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _pw_context_set_object(
      context,
      type,
      value,
    );
  }

  late final _pw_context_set_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('pw_context_set_object');
  late final _pw_context_set_object = _pw_context_set_objectPtr.asFunction<
      int Function(ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>)>();

  /// get an object from the context
  ffi.Pointer<ffi.Void> pw_context_get_object(
    ffi.Pointer<pw_context> context,
    ffi.Pointer<ffi.Char> type,
  ) {
    return _pw_context_get_object(
      context,
      type,
    );
  }

  late final _pw_context_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<pw_context>,
              ffi.Pointer<ffi.Char>)>>('pw_context_get_object');
  late final _pw_context_get_object = _pw_context_get_objectPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<pw_context>, ffi.Pointer<ffi.Char>)>();

  /// Create a new main loop.
  ffi.Pointer<pw_main_loop> pw_main_loop_new(
    ffi.Pointer<spa_dict> props,
  ) {
    return _pw_main_loop_new(
      props,
    );
  }

  late final _pw_main_loop_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_main_loop> Function(
              ffi.Pointer<spa_dict>)>>('pw_main_loop_new');
  late final _pw_main_loop_new = _pw_main_loop_newPtr
      .asFunction<ffi.Pointer<pw_main_loop> Function(ffi.Pointer<spa_dict>)>();

  /// Add an event listener
  void pw_main_loop_add_listener(
    ffi.Pointer<pw_main_loop> loop,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_main_loop_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_main_loop_add_listener(
      loop,
      listener,
      events,
      data,
    );
  }

  late final _pw_main_loop_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_main_loop>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_main_loop_events>,
              ffi.Pointer<ffi.Void>)>>('pw_main_loop_add_listener');
  late final _pw_main_loop_add_listener =
      _pw_main_loop_add_listenerPtr.asFunction<
          void Function(ffi.Pointer<pw_main_loop>, ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_main_loop_events>, ffi.Pointer<ffi.Void>)>();

  /// Get the loop implementation
  ffi.Pointer<pw_loop> pw_main_loop_get_loop(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_get_loop(
      loop,
    );
  }

  late final _pw_main_loop_get_loopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_loop> Function(
              ffi.Pointer<pw_main_loop>)>>('pw_main_loop_get_loop');
  late final _pw_main_loop_get_loop = _pw_main_loop_get_loopPtr
      .asFunction<ffi.Pointer<pw_loop> Function(ffi.Pointer<pw_main_loop>)>();

  /// Destroy a loop
  void pw_main_loop_destroy(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_destroy(
      loop,
    );
  }

  late final _pw_main_loop_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_destroy');
  late final _pw_main_loop_destroy = _pw_main_loop_destroyPtr
      .asFunction<void Function(ffi.Pointer<pw_main_loop>)>();

  /// Run a main loop. This blocks until \ref pw_main_loop_quit is called
  int pw_main_loop_run(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_run(
      loop,
    );
  }

  late final _pw_main_loop_runPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_run');
  late final _pw_main_loop_run = _pw_main_loop_runPtr
      .asFunction<int Function(ffi.Pointer<pw_main_loop>)>();

  /// Quit a main loop
  int pw_main_loop_quit(
    ffi.Pointer<pw_main_loop> loop,
  ) {
    return _pw_main_loop_quit(
      loop,
    );
  }

  late final _pw_main_loop_quitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_main_loop>)>>(
          'pw_main_loop_quit');
  late final _pw_main_loop_quit = _pw_main_loop_quitPtr
      .asFunction<int Function(ffi.Pointer<pw_main_loop>)>();

  /// Convert a stream state to a readable string
  ffi.Pointer<ffi.Char> pw_stream_state_as_string(
    pw_stream_state state,
  ) {
    return _pw_stream_state_as_string(
      state.value,
    );
  }

  late final _pw_stream_state_as_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'pw_stream_state_as_string');
  late final _pw_stream_state_as_string = _pw_stream_state_as_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Create a new unconneced \ref pw_stream
  /// \return a newly allocated \ref pw_stream
  ffi.Pointer<pw_stream> pw_stream_new(
    ffi.Pointer<pw_core> core,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
  ) {
    return _pw_stream_new(
      core,
      name,
      props,
    );
  }

  late final _pw_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream> Function(
              ffi.Pointer<pw_core>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>)>>('pw_stream_new');
  late final _pw_stream_new = _pw_stream_newPtr.asFunction<
      ffi.Pointer<pw_stream> Function(ffi.Pointer<pw_core>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<pw_properties>)>();

  ffi.Pointer<pw_stream> pw_stream_new_simple(
    ffi.Pointer<pw_loop> loop,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<pw_properties> props,
    ffi.Pointer<pw_stream_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_stream_new_simple(
      loop,
      name,
      props,
      events,
      data,
    );
  }

  late final _pw_stream_new_simplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream> Function(
              ffi.Pointer<pw_loop>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<pw_properties>,
              ffi.Pointer<pw_stream_events>,
              ffi.Pointer<ffi.Void>)>>('pw_stream_new_simple');
  late final _pw_stream_new_simple = _pw_stream_new_simplePtr.asFunction<
      ffi.Pointer<pw_stream> Function(
          ffi.Pointer<pw_loop>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<pw_properties>,
          ffi.Pointer<pw_stream_events>,
          ffi.Pointer<ffi.Void>)>();

  /// Destroy a stream
  void pw_stream_destroy(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_destroy(
      stream,
    );
  }

  late final _pw_stream_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_destroy');
  late final _pw_stream_destroy =
      _pw_stream_destroyPtr.asFunction<void Function(ffi.Pointer<pw_stream>)>();

  void pw_stream_add_listener(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<spa_hook> listener,
    ffi.Pointer<pw_stream_events> events,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _pw_stream_add_listener(
      stream,
      listener,
      events,
      data,
    );
  }

  late final _pw_stream_add_listenerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<pw_stream>,
              ffi.Pointer<spa_hook>,
              ffi.Pointer<pw_stream_events>,
              ffi.Pointer<ffi.Void>)>>('pw_stream_add_listener');
  late final _pw_stream_add_listener = _pw_stream_add_listenerPtr.asFunction<
      void Function(ffi.Pointer<pw_stream>, ffi.Pointer<spa_hook>,
          ffi.Pointer<pw_stream_events>, ffi.Pointer<ffi.Void>)>();

  pw_stream_state pw_stream_get_state(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return pw_stream_state.fromValue(_pw_stream_get_state(
      stream,
      error,
    ));
  }

  late final _pw_stream_get_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('pw_stream_get_state');
  late final _pw_stream_get_state = _pw_stream_get_statePtr.asFunction<
      int Function(
          ffi.Pointer<pw_stream>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> pw_stream_get_name(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_name(
      stream,
    );
  }

  late final _pw_stream_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_name');
  late final _pw_stream_get_name = _pw_stream_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<pw_stream>)>();

  ffi.Pointer<pw_core> pw_stream_get_core(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_core(
      stream,
    );
  }

  late final _pw_stream_get_corePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_core> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_core');
  late final _pw_stream_get_core = _pw_stream_get_corePtr
      .asFunction<ffi.Pointer<pw_core> Function(ffi.Pointer<pw_stream>)>();

  ffi.Pointer<pw_properties> pw_stream_get_properties(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_properties(
      stream,
    );
  }

  late final _pw_stream_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_properties> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_get_properties');
  late final _pw_stream_get_properties =
      _pw_stream_get_propertiesPtr.asFunction<
          ffi.Pointer<pw_properties> Function(ffi.Pointer<pw_stream>)>();

  int pw_stream_update_properties(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<spa_dict> dict,
  ) {
    return _pw_stream_update_properties(
      stream,
      dict,
    );
  }

  late final _pw_stream_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<spa_dict>)>>('pw_stream_update_properties');
  late final _pw_stream_update_properties =
      _pw_stream_update_propertiesPtr.asFunction<
          int Function(ffi.Pointer<pw_stream>, ffi.Pointer<spa_dict>)>();

  /// Connect a stream for input or output on \a port_path.
  /// \return 0 on success < 0 on error.
  ///
  /// You should connect to the process event and use pw_stream_dequeue_buffer()
  /// to get the latest metadata and data.
  int pw_stream_connect(
    ffi.Pointer<pw_stream> stream,
    spa_direction direction,
    int target_id,
    pw_stream_flags flags,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_stream_connect(
      stream,
      direction.value,
      target_id,
      flags.value,
      params,
      n_params,
    );
  }

  late final _pw_stream_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>,
              ffi.UnsignedInt,
              ffi.Uint32,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_stream_connect');
  late final _pw_stream_connect = _pw_stream_connectPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, int, int,
          ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Get the node ID of the stream.
  /// \return node ID.
  int pw_stream_get_node_id(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_get_node_id(
      stream,
    );
  }

  late final _pw_stream_get_node_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_get_node_id');
  late final _pw_stream_get_node_id = _pw_stream_get_node_idPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// Disconnect \a stream
  int pw_stream_disconnect(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_disconnect(
      stream,
    );
  }

  late final _pw_stream_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_disconnect');
  late final _pw_stream_disconnect = _pw_stream_disconnectPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// Set the stream in error state
  int pw_stream_set_error(
    ffi.Pointer<pw_stream> stream,
    int res,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _pw_stream_set_error(
      stream,
      res,
      error,
    );
  }

  late final _pw_stream_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('pw_stream_set_error');
  late final _pw_stream_set_error = _pw_stream_set_errorPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, ffi.Pointer<ffi.Char>)>();

  /// Complete the negotiation process with result code \a res
  ///
  /// This function should be called after notification of the format.
  ///
  /// When \a res indicates success, \a params contain the parameters for the
  /// allocation state.
  int pw_stream_update_params(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<ffi.Pointer<spa_pod>> params,
    int n_params,
  ) {
    return _pw_stream_update_params(
      stream,
      params,
      n_params,
    );
  }

  late final _pw_stream_update_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<pw_stream>,
              ffi.Pointer<ffi.Pointer<spa_pod>>,
              ffi.Uint32)>>('pw_stream_update_params');
  late final _pw_stream_update_params = _pw_stream_update_paramsPtr.asFunction<
      int Function(
          ffi.Pointer<pw_stream>, ffi.Pointer<ffi.Pointer<spa_pod>>, int)>();

  /// Get control values
  ffi.Pointer<pw_stream_control> pw_stream_get_control(
    ffi.Pointer<pw_stream> stream,
    int id,
  ) {
    return _pw_stream_get_control(
      stream,
      id,
    );
  }

  late final _pw_stream_get_controlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_stream_control> Function(
              ffi.Pointer<pw_stream>, ffi.Uint32)>>('pw_stream_get_control');
  late final _pw_stream_get_control = _pw_stream_get_controlPtr.asFunction<
      ffi.Pointer<pw_stream_control> Function(ffi.Pointer<pw_stream>, int)>();

  /// Set control values
  int pw_stream_set_control(
    ffi.Pointer<pw_stream> stream,
    int id,
    int n_values,
    ffi.Pointer<ffi.Float> values,
  ) {
    return _pw_stream_set_control(
      stream,
      id,
      n_values,
      values,
    );
  }

  late final _pw_stream_set_controlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Float>)>>('pw_stream_set_control');
  late final _pw_stream_set_control = _pw_stream_set_controlPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, int, int, ffi.Pointer<ffi.Float>)>();

  /// Query the time on the stream
  int pw_stream_get_time(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<pw_time> time,
  ) {
    return _pw_stream_get_time(
      stream,
      time,
    );
  }

  late final _pw_stream_get_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<pw_time>)>>('pw_stream_get_time');
  late final _pw_stream_get_time = _pw_stream_get_timePtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, ffi.Pointer<pw_time>)>();

  /// Get a buffer that can be filled for playback streams or consumed
  /// for capture streams.
  ffi.Pointer<pw_buffer> pw_stream_dequeue_buffer(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_dequeue_buffer(
      stream,
    );
  }

  late final _pw_stream_dequeue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_buffer> Function(
              ffi.Pointer<pw_stream>)>>('pw_stream_dequeue_buffer');
  late final _pw_stream_dequeue_buffer = _pw_stream_dequeue_bufferPtr
      .asFunction<ffi.Pointer<pw_buffer> Function(ffi.Pointer<pw_stream>)>();

  /// Submit a buffer for playback or recycle a buffer for capture.
  int pw_stream_queue_buffer(
    ffi.Pointer<pw_stream> stream,
    ffi.Pointer<pw_buffer> buffer,
  ) {
    return _pw_stream_queue_buffer(
      stream,
      buffer,
    );
  }

  late final _pw_stream_queue_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<pw_stream>,
              ffi.Pointer<pw_buffer>)>>('pw_stream_queue_buffer');
  late final _pw_stream_queue_buffer = _pw_stream_queue_bufferPtr.asFunction<
      int Function(ffi.Pointer<pw_stream>, ffi.Pointer<pw_buffer>)>();

  /// Activate or deactivate the stream
  int pw_stream_set_active(
    ffi.Pointer<pw_stream> stream,
    bool active,
  ) {
    return _pw_stream_set_active(
      stream,
      active,
    );
  }

  late final _pw_stream_set_activePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Bool)>>(
      'pw_stream_set_active');
  late final _pw_stream_set_active = _pw_stream_set_activePtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, bool)>();

  /// Flush a stream. When \a drain is true, the drained callback will
  /// be called when all data is played or recorded
  int pw_stream_flush(
    ffi.Pointer<pw_stream> stream,
    bool drain,
  ) {
    return _pw_stream_flush(
      stream,
      drain,
    );
  }

  late final _pw_stream_flushPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>, ffi.Bool)>>(
      'pw_stream_flush');
  late final _pw_stream_flush = _pw_stream_flushPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>, bool)>();

  /// Check if the stream is driving. The stream needs to have the
  /// PW_STREAM_FLAG_DRIVER set. When the stream is driving,
  /// pw_stream_trigger_process() needs to be called when data is
  /// available (output) or needed (input). Since 0.3.34
  bool pw_stream_is_driving(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_is_driving(
      stream,
    );
  }

  late final _pw_stream_is_drivingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_is_driving');
  late final _pw_stream_is_driving = _pw_stream_is_drivingPtr
      .asFunction<bool Function(ffi.Pointer<pw_stream>)>();

  /// Trigger a push/pull on the stream. One iteration of the graph will
  /// scheduled and process() will be called. Since 0.3.34
  int pw_stream_trigger_process(
    ffi.Pointer<pw_stream> stream,
  ) {
    return _pw_stream_trigger_process(
      stream,
    );
  }

  late final _pw_stream_trigger_processPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<pw_stream>)>>(
          'pw_stream_trigger_process');
  late final _pw_stream_trigger_process = _pw_stream_trigger_processPtr
      .asFunction<int Function(ffi.Pointer<pw_stream>)>();

  /// \addtogroup pw_pipewire
  /// \{
  void pw_init(
    ffi.Pointer<ffi.Int> argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> argv,
  ) {
    return _pw_init(
      argc,
      argv,
    );
  }

  late final _pw_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>>('pw_init');
  late final _pw_init = _pw_initPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>();

  void pw_deinit() {
    return _pw_deinit();
  }

  late final _pw_deinitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('pw_deinit');
  late final _pw_deinit = _pw_deinitPtr.asFunction<void Function()>();

  bool pw_debug_is_category_enabled(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _pw_debug_is_category_enabled(
      name,
    );
  }

  late final _pw_debug_is_category_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'pw_debug_is_category_enabled');
  late final _pw_debug_is_category_enabled = _pw_debug_is_category_enabledPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_application_name() {
    return _pw_get_application_name();
  }

  late final _pw_get_application_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_application_name');
  late final _pw_get_application_name = _pw_get_application_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_prgname() {
    return _pw_get_prgname();
  }

  late final _pw_get_prgnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_prgname');
  late final _pw_get_prgname =
      _pw_get_prgnamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_user_name() {
    return _pw_get_user_name();
  }

  late final _pw_get_user_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_user_name');
  late final _pw_get_user_name =
      _pw_get_user_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_host_name() {
    return _pw_get_host_name();
  }

  late final _pw_get_host_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_host_name');
  late final _pw_get_host_name =
      _pw_get_host_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> pw_get_client_name() {
    return _pw_get_client_name();
  }

  late final _pw_get_client_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_client_name');
  late final _pw_get_client_name =
      _pw_get_client_namePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  bool pw_in_valgrind() {
    return _pw_in_valgrind();
  }

  late final _pw_in_valgrindPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('pw_in_valgrind');
  late final _pw_in_valgrind = _pw_in_valgrindPtr.asFunction<bool Function()>();

  bool pw_check_option(
    ffi.Pointer<ffi.Char> option,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _pw_check_option(
      option,
      value,
    );
  }

  late final _pw_check_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('pw_check_option');
  late final _pw_check_option = _pw_check_optionPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  spa_direction pw_direction_reverse(
    spa_direction direction,
  ) {
    return spa_direction.fromValue(_pw_direction_reverse(
      direction.value,
    ));
  }

  late final _pw_direction_reversePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'pw_direction_reverse');
  late final _pw_direction_reverse =
      _pw_direction_reversePtr.asFunction<int Function(int)>();

  int pw_set_domain(
    ffi.Pointer<ffi.Char> domain,
  ) {
    return _pw_set_domain(
      domain,
    );
  }

  late final _pw_set_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'pw_set_domain');
  late final _pw_set_domain =
      _pw_set_domainPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> pw_get_domain() {
    return _pw_get_domain();
  }

  late final _pw_get_domainPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'pw_get_domain');
  late final _pw_get_domain =
      _pw_get_domainPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int pw_get_support(
    ffi.Pointer<spa_support> support,
    int max_support,
  ) {
    return _pw_get_support(
      support,
      max_support,
    );
  }

  late final _pw_get_supportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<spa_support>, ffi.Uint32)>>('pw_get_support');
  late final _pw_get_support = _pw_get_supportPtr
      .asFunction<int Function(ffi.Pointer<spa_support>, int)>();

  ffi.Pointer<spa_handle> pw_load_spa_handle(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> factory_name,
    ffi.Pointer<spa_dict> info,
    int n_support,
    ffi.Pointer<spa_support> support,
  ) {
    return _pw_load_spa_handle(
      lib,
      factory_name,
      info,
      n_support,
      support,
    );
  }

  late final _pw_load_spa_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<spa_handle> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<spa_dict>,
              ffi.Uint32,
              ffi.Pointer<spa_support>)>>('pw_load_spa_handle');
  late final _pw_load_spa_handle = _pw_load_spa_handlePtr.asFunction<
      ffi.Pointer<spa_handle> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<spa_dict>,
          int,
          ffi.Pointer<spa_support>)>();

  int pw_unload_spa_handle(
    ffi.Pointer<spa_handle> handle,
  ) {
    return _pw_unload_spa_handle(
      handle,
    );
  }

  late final _pw_unload_spa_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle>)>>(
          'pw_unload_spa_handle');
  late final _pw_unload_spa_handle = _pw_unload_spa_handlePtr
      .asFunction<int Function(ffi.Pointer<spa_handle>)>();

  void g_hook_list_init(
    ffi.Pointer<GHookList> hook_list,
    int hook_size,
  ) {
    return _g_hook_list_init(
      hook_list,
      hook_size,
    );
  }

  late final _g_hook_list_initPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GHookList>, guint)>>(
      'g_hook_list_init');
  late final _g_hook_list_init = _g_hook_list_initPtr
      .asFunction<void Function(ffi.Pointer<GHookList>, int)>();

  void g_hook_list_clear(
    ffi.Pointer<GHookList> hook_list,
  ) {
    return _g_hook_list_clear(
      hook_list,
    );
  }

  late final _g_hook_list_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GHookList>)>>(
          'g_hook_list_clear');
  late final _g_hook_list_clear =
      _g_hook_list_clearPtr.asFunction<void Function(ffi.Pointer<GHookList>)>();

  ffi.Pointer<GHook> g_hook_alloc(
    ffi.Pointer<GHookList> hook_list,
  ) {
    return _g_hook_alloc(
      hook_list,
    );
  }

  late final _g_hook_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>)>>('g_hook_alloc');
  late final _g_hook_alloc = _g_hook_allocPtr
      .asFunction<ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>)>();

  void g_hook_free(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_free(
      hook_list,
      hook,
    );
  }

  late final _g_hook_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>>('g_hook_free');
  late final _g_hook_free = _g_hook_freePtr
      .asFunction<void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>();

  ffi.Pointer<GHook> g_hook_ref(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_ref(
      hook_list,
      hook,
    );
  }

  late final _g_hook_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(
              ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>>('g_hook_ref');
  late final _g_hook_ref = _g_hook_refPtr.asFunction<
      ffi.Pointer<GHook> Function(
          ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>();

  void g_hook_unref(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_unref(
      hook_list,
      hook,
    );
  }

  late final _g_hook_unrefPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>>('g_hook_unref');
  late final _g_hook_unref = _g_hook_unrefPtr
      .asFunction<void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>();

  int g_hook_destroy(
    ffi.Pointer<GHookList> hook_list,
    int hook_id,
  ) {
    return _g_hook_destroy(
      hook_list,
      hook_id,
    );
  }

  late final _g_hook_destroyPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GHookList>, gulong)>>('g_hook_destroy');
  late final _g_hook_destroy = _g_hook_destroyPtr
      .asFunction<int Function(ffi.Pointer<GHookList>, int)>();

  void g_hook_destroy_link(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_destroy_link(
      hook_list,
      hook,
    );
  }

  late final _g_hook_destroy_linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GHookList>,
              ffi.Pointer<GHook>)>>('g_hook_destroy_link');
  late final _g_hook_destroy_link = _g_hook_destroy_linkPtr
      .asFunction<void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>();

  void g_hook_prepend(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_prepend(
      hook_list,
      hook,
    );
  }

  late final _g_hook_prependPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>>('g_hook_prepend');
  late final _g_hook_prepend = _g_hook_prependPtr
      .asFunction<void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>)>();

  void g_hook_insert_before(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> sibling,
    ffi.Pointer<GHook> hook,
  ) {
    return _g_hook_insert_before(
      hook_list,
      sibling,
      hook,
    );
  }

  late final _g_hook_insert_beforePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>,
              ffi.Pointer<GHook>)>>('g_hook_insert_before');
  late final _g_hook_insert_before = _g_hook_insert_beforePtr.asFunction<
      void Function(
          ffi.Pointer<GHookList>, ffi.Pointer<GHook>, ffi.Pointer<GHook>)>();

  void g_hook_insert_sorted(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
    GHookCompareFunc func,
  ) {
    return _g_hook_insert_sorted(
      hook_list,
      hook,
      func,
    );
  }

  late final _g_hook_insert_sortedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GHookList>, ffi.Pointer<GHook>,
              GHookCompareFunc)>>('g_hook_insert_sorted');
  late final _g_hook_insert_sorted = _g_hook_insert_sortedPtr.asFunction<
      void Function(
          ffi.Pointer<GHookList>, ffi.Pointer<GHook>, GHookCompareFunc)>();

  ffi.Pointer<GHook> g_hook_get(
    ffi.Pointer<GHookList> hook_list,
    int hook_id,
  ) {
    return _g_hook_get(
      hook_list,
      hook_id,
    );
  }

  late final _g_hook_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(
              ffi.Pointer<GHookList>, gulong)>>('g_hook_get');
  late final _g_hook_get = _g_hook_getPtr
      .asFunction<ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, int)>();

  ffi.Pointer<GHook> g_hook_find(
    ffi.Pointer<GHookList> hook_list,
    int need_valids,
    GHookFindFunc func,
    gpointer data,
  ) {
    return _g_hook_find(
      hook_list,
      need_valids,
      func,
      data,
    );
  }

  late final _g_hook_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, gboolean,
              GHookFindFunc, gpointer)>>('g_hook_find');
  late final _g_hook_find = _g_hook_findPtr.asFunction<
      ffi.Pointer<GHook> Function(
          ffi.Pointer<GHookList>, int, GHookFindFunc, gpointer)>();

  ffi.Pointer<GHook> g_hook_find_data(
    ffi.Pointer<GHookList> hook_list,
    int need_valids,
    gpointer data,
  ) {
    return _g_hook_find_data(
      hook_list,
      need_valids,
      data,
    );
  }

  late final _g_hook_find_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(
              ffi.Pointer<GHookList>, gboolean, gpointer)>>('g_hook_find_data');
  late final _g_hook_find_data = _g_hook_find_dataPtr.asFunction<
      ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, int, gpointer)>();

  ffi.Pointer<GHook> g_hook_find_func(
    ffi.Pointer<GHookList> hook_list,
    int need_valids,
    gpointer func,
  ) {
    return _g_hook_find_func(
      hook_list,
      need_valids,
      func,
    );
  }

  late final _g_hook_find_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(
              ffi.Pointer<GHookList>, gboolean, gpointer)>>('g_hook_find_func');
  late final _g_hook_find_func = _g_hook_find_funcPtr.asFunction<
      ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, int, gpointer)>();

  ffi.Pointer<GHook> g_hook_find_func_data(
    ffi.Pointer<GHookList> hook_list,
    int need_valids,
    gpointer func,
    gpointer data,
  ) {
    return _g_hook_find_func_data(
      hook_list,
      need_valids,
      func,
      data,
    );
  }

  late final _g_hook_find_func_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, gboolean,
              gpointer, gpointer)>>('g_hook_find_func_data');
  late final _g_hook_find_func_data = _g_hook_find_func_dataPtr.asFunction<
      ffi.Pointer<GHook> Function(
          ffi.Pointer<GHookList>, int, gpointer, gpointer)>();

  ffi.Pointer<GHook> g_hook_first_valid(
    ffi.Pointer<GHookList> hook_list,
    int may_be_in_call,
  ) {
    return _g_hook_first_valid(
      hook_list,
      may_be_in_call,
    );
  }

  late final _g_hook_first_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(
              ffi.Pointer<GHookList>, gboolean)>>('g_hook_first_valid');
  late final _g_hook_first_valid = _g_hook_first_validPtr
      .asFunction<ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>, int)>();

  ffi.Pointer<GHook> g_hook_next_valid(
    ffi.Pointer<GHookList> hook_list,
    ffi.Pointer<GHook> hook,
    int may_be_in_call,
  ) {
    return _g_hook_next_valid(
      hook_list,
      hook,
      may_be_in_call,
    );
  }

  late final _g_hook_next_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GHook> Function(ffi.Pointer<GHookList>,
              ffi.Pointer<GHook>, gboolean)>>('g_hook_next_valid');
  late final _g_hook_next_valid = _g_hook_next_validPtr.asFunction<
      ffi.Pointer<GHook> Function(
          ffi.Pointer<GHookList>, ffi.Pointer<GHook>, int)>();

  int g_hook_compare_ids(
    ffi.Pointer<GHook> new_hook,
    ffi.Pointer<GHook> sibling,
  ) {
    return _g_hook_compare_ids(
      new_hook,
      sibling,
    );
  }

  late final _g_hook_compare_idsPtr = _lookup<
      ffi.NativeFunction<
          gint Function(
              ffi.Pointer<GHook>, ffi.Pointer<GHook>)>>('g_hook_compare_ids');
  late final _g_hook_compare_ids = _g_hook_compare_idsPtr
      .asFunction<int Function(ffi.Pointer<GHook>, ffi.Pointer<GHook>)>();

  void g_hook_list_invoke(
    ffi.Pointer<GHookList> hook_list,
    int may_recurse,
  ) {
    return _g_hook_list_invoke(
      hook_list,
      may_recurse,
    );
  }

  late final _g_hook_list_invokePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GHookList>, gboolean)>>(
      'g_hook_list_invoke');
  late final _g_hook_list_invoke = _g_hook_list_invokePtr
      .asFunction<void Function(ffi.Pointer<GHookList>, int)>();

  void g_hook_list_invoke_check(
    ffi.Pointer<GHookList> hook_list,
    int may_recurse,
  ) {
    return _g_hook_list_invoke_check(
      hook_list,
      may_recurse,
    );
  }

  late final _g_hook_list_invoke_checkPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GHookList>, gboolean)>>(
      'g_hook_list_invoke_check');
  late final _g_hook_list_invoke_check = _g_hook_list_invoke_checkPtr
      .asFunction<void Function(ffi.Pointer<GHookList>, int)>();

  void g_hook_list_marshal(
    ffi.Pointer<GHookList> hook_list,
    int may_recurse,
    GHookMarshaller marshaller,
    gpointer marshal_data,
  ) {
    return _g_hook_list_marshal(
      hook_list,
      may_recurse,
      marshaller,
      marshal_data,
    );
  }

  late final _g_hook_list_marshalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GHookList>, gboolean, GHookMarshaller,
              gpointer)>>('g_hook_list_marshal');
  late final _g_hook_list_marshal = _g_hook_list_marshalPtr.asFunction<
      void Function(ffi.Pointer<GHookList>, int, GHookMarshaller, gpointer)>();

  void g_hook_list_marshal_check(
    ffi.Pointer<GHookList> hook_list,
    int may_recurse,
    GHookCheckMarshaller marshaller,
    gpointer marshal_data,
  ) {
    return _g_hook_list_marshal_check(
      hook_list,
      may_recurse,
      marshaller,
      marshal_data,
    );
  }

  late final _g_hook_list_marshal_checkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GHookList>, gboolean,
              GHookCheckMarshaller, gpointer)>>('g_hook_list_marshal_check');
  late final _g_hook_list_marshal_check =
      _g_hook_list_marshal_checkPtr.asFunction<
          void Function(
              ffi.Pointer<GHookList>, int, GHookCheckMarshaller, gpointer)>();

  int g_type_plugin_get_type() {
    return _g_type_plugin_get_type();
  }

  late final _g_type_plugin_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('g_type_plugin_get_type');
  late final _g_type_plugin_get_type =
      _g_type_plugin_get_typePtr.asFunction<int Function()>();

  void g_type_plugin_use(
    ffi.Pointer<GTypePlugin> plugin,
  ) {
    return _g_type_plugin_use(
      plugin,
    );
  }

  late final _g_type_plugin_usePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GTypePlugin>)>>(
          'g_type_plugin_use');
  late final _g_type_plugin_use = _g_type_plugin_usePtr
      .asFunction<void Function(ffi.Pointer<GTypePlugin>)>();

  void g_type_plugin_unuse(
    ffi.Pointer<GTypePlugin> plugin,
  ) {
    return _g_type_plugin_unuse(
      plugin,
    );
  }

  late final _g_type_plugin_unusePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GTypePlugin>)>>(
          'g_type_plugin_unuse');
  late final _g_type_plugin_unuse = _g_type_plugin_unusePtr
      .asFunction<void Function(ffi.Pointer<GTypePlugin>)>();

  void g_type_plugin_complete_type_info(
    ffi.Pointer<GTypePlugin> plugin,
    int g_type,
    ffi.Pointer<GTypeInfo> info,
    ffi.Pointer<GTypeValueTable> value_table,
  ) {
    return _g_type_plugin_complete_type_info(
      plugin,
      g_type,
      info,
      value_table,
    );
  }

  late final _g_type_plugin_complete_type_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GTypePlugin>, GType,
                  ffi.Pointer<GTypeInfo>, ffi.Pointer<GTypeValueTable>)>>(
      'g_type_plugin_complete_type_info');
  late final _g_type_plugin_complete_type_info =
      _g_type_plugin_complete_type_infoPtr.asFunction<
          void Function(ffi.Pointer<GTypePlugin>, int, ffi.Pointer<GTypeInfo>,
              ffi.Pointer<GTypeValueTable>)>();

  void g_type_plugin_complete_interface_info(
    ffi.Pointer<GTypePlugin> plugin,
    int instance_type,
    int interface_type,
    ffi.Pointer<GInterfaceInfo> info,
  ) {
    return _g_type_plugin_complete_interface_info(
      plugin,
      instance_type,
      interface_type,
      info,
    );
  }

  late final _g_type_plugin_complete_interface_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GTypePlugin>, GType, GType,
                  ffi.Pointer<GInterfaceInfo>)>>(
      'g_type_plugin_complete_interface_info');
  late final _g_type_plugin_complete_interface_info =
      _g_type_plugin_complete_interface_infoPtr.asFunction<
          void Function(ffi.Pointer<GTypePlugin>, int, int,
              ffi.Pointer<GInterfaceInfo>)>();

  int g_async_result_get_type() {
    return _g_async_result_get_type();
  }

  late final _g_async_result_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('g_async_result_get_type');
  late final _g_async_result_get_type =
      _g_async_result_get_typePtr.asFunction<int Function()>();

  gpointer g_async_result_get_user_data(
    ffi.Pointer<GAsyncResult> res,
  ) {
    return _g_async_result_get_user_data(
      res,
    );
  }

  late final _g_async_result_get_user_dataPtr =
      _lookup<ffi.NativeFunction<gpointer Function(ffi.Pointer<GAsyncResult>)>>(
          'g_async_result_get_user_data');
  late final _g_async_result_get_user_data = _g_async_result_get_user_dataPtr
      .asFunction<gpointer Function(ffi.Pointer<GAsyncResult>)>();

  ffi.Pointer<GObject> g_async_result_get_source_object(
    ffi.Pointer<GAsyncResult> res,
  ) {
    return _g_async_result_get_source_object(
      res,
    );
  }

  late final _g_async_result_get_source_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GObject> Function(
              ffi.Pointer<GAsyncResult>)>>('g_async_result_get_source_object');
  late final _g_async_result_get_source_object =
      _g_async_result_get_source_objectPtr.asFunction<
          ffi.Pointer<GObject> Function(ffi.Pointer<GAsyncResult>)>();

  int g_async_result_legacy_propagate_error(
    ffi.Pointer<GAsyncResult> res,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_async_result_legacy_propagate_error(
      res,
      error,
    );
  }

  late final _g_async_result_legacy_propagate_errorPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_async_result_legacy_propagate_error');
  late final _g_async_result_legacy_propagate_error =
      _g_async_result_legacy_propagate_errorPtr.asFunction<
          int Function(
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_async_result_is_tagged(
    ffi.Pointer<GAsyncResult> res,
    gpointer source_tag,
  ) {
    return _g_async_result_is_tagged(
      res,
      source_tag,
    );
  }

  late final _g_async_result_is_taggedPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GAsyncResult>,
              gpointer)>>('g_async_result_is_tagged');
  late final _g_async_result_is_tagged = _g_async_result_is_taggedPtr
      .asFunction<int Function(ffi.Pointer<GAsyncResult>, gpointer)>();

  int g_input_stream_get_type() {
    return _g_input_stream_get_type();
  }

  late final _g_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('g_input_stream_get_type');
  late final _g_input_stream_get_type =
      _g_input_stream_get_typePtr.asFunction<int Function()>();

  int g_input_stream_read(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read(
      stream,
      buffer,
      count,
      cancellable,
      error,
    );
  }

  late final _g_input_stream_readPtr = _lookup<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_read');
  late final _g_input_stream_read = _g_input_stream_readPtr.asFunction<
      int Function(ffi.Pointer<GInputStream>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_input_stream_read_all(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<gsize> bytes_read,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read_all(
      stream,
      buffer,
      count,
      bytes_read,
      cancellable,
      error,
    );
  }

  late final _g_input_stream_read_allPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_read_all');
  late final _g_input_stream_read_all = _g_input_stream_read_allPtr.asFunction<
      int Function(
          ffi.Pointer<GInputStream>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<gsize>,
          ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<GBytes> g_input_stream_read_bytes(
    ffi.Pointer<GInputStream> stream,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read_bytes(
      stream,
      count,
      cancellable,
      error,
    );
  }

  late final _g_input_stream_read_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GBytes> Function(
              ffi.Pointer<GInputStream>,
              gsize,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_read_bytes');
  late final _g_input_stream_read_bytes =
      _g_input_stream_read_bytesPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<GInputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_input_stream_skip(
    ffi.Pointer<GInputStream> stream,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_skip(
      stream,
      count,
      cancellable,
      error,
    );
  }

  late final _g_input_stream_skipPtr = _lookup<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream>,
              gsize,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_skip');
  late final _g_input_stream_skip = _g_input_stream_skipPtr.asFunction<
      int Function(ffi.Pointer<GInputStream>, int, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_input_stream_close(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_close(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_input_stream_closePtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_close');
  late final _g_input_stream_close = _g_input_stream_closePtr.asFunction<
      int Function(ffi.Pointer<GInputStream>, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_read_async(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_input_stream_read_async(
      stream,
      buffer,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_input_stream_read_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_input_stream_read_async');
  late final _g_input_stream_read_async =
      _g_input_stream_read_asyncPtr.asFunction<
          void Function(ffi.Pointer<GInputStream>, ffi.Pointer<ffi.Void>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_input_stream_read_finish(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_input_stream_read_finishPtr = _lookup<
      ffi.NativeFunction<
          gssize Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_read_finish');
  late final _g_input_stream_read_finish =
      _g_input_stream_read_finishPtr.asFunction<
          int Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_read_all_async(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_input_stream_read_all_async(
      stream,
      buffer,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_input_stream_read_all_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_input_stream_read_all_async');
  late final _g_input_stream_read_all_async =
      _g_input_stream_read_all_asyncPtr.asFunction<
          void Function(ffi.Pointer<GInputStream>, ffi.Pointer<ffi.Void>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_input_stream_read_all_finish(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> bytes_read,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read_all_finish(
      stream,
      result,
      bytes_read,
      error,
    );
  }

  late final _g_input_stream_read_all_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_input_stream_read_all_finish');
  late final _g_input_stream_read_all_finish =
      _g_input_stream_read_all_finishPtr.asFunction<
          int Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_read_bytes_async(
    ffi.Pointer<GInputStream> stream,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_input_stream_read_bytes_async(
      stream,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_input_stream_read_bytes_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_input_stream_read_bytes_async');
  late final _g_input_stream_read_bytes_async =
      _g_input_stream_read_bytes_asyncPtr.asFunction<
          void Function(ffi.Pointer<GInputStream>, int, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<GBytes> g_input_stream_read_bytes_finish(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_read_bytes_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_input_stream_read_bytes_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(
                  ffi.Pointer<GInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_input_stream_read_bytes_finish');
  late final _g_input_stream_read_bytes_finish =
      _g_input_stream_read_bytes_finishPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<GInputStream>,
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_skip_async(
    ffi.Pointer<GInputStream> stream,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_input_stream_skip_async(
      stream,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_input_stream_skip_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_input_stream_skip_async');
  late final _g_input_stream_skip_async =
      _g_input_stream_skip_asyncPtr.asFunction<
          void Function(ffi.Pointer<GInputStream>, int, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_input_stream_skip_finish(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_skip_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_input_stream_skip_finishPtr = _lookup<
      ffi.NativeFunction<
          gssize Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_skip_finish');
  late final _g_input_stream_skip_finish =
      _g_input_stream_skip_finishPtr.asFunction<
          int Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_close_async(
    ffi.Pointer<GInputStream> stream,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_input_stream_close_async(
      stream,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_input_stream_close_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_input_stream_close_async');
  late final _g_input_stream_close_async =
      _g_input_stream_close_asyncPtr.asFunction<
          void Function(ffi.Pointer<GInputStream>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_input_stream_close_finish(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_close_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_input_stream_close_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_input_stream_close_finish');
  late final _g_input_stream_close_finish =
      _g_input_stream_close_finishPtr.asFunction<
          int Function(ffi.Pointer<GInputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_input_stream_is_closed(
    ffi.Pointer<GInputStream> stream,
  ) {
    return _g_input_stream_is_closed(
      stream,
    );
  }

  late final _g_input_stream_is_closedPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<GInputStream>)>>(
          'g_input_stream_is_closed');
  late final _g_input_stream_is_closed = _g_input_stream_is_closedPtr
      .asFunction<int Function(ffi.Pointer<GInputStream>)>();

  int g_input_stream_has_pending(
    ffi.Pointer<GInputStream> stream,
  ) {
    return _g_input_stream_has_pending(
      stream,
    );
  }

  late final _g_input_stream_has_pendingPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<GInputStream>)>>(
          'g_input_stream_has_pending');
  late final _g_input_stream_has_pending = _g_input_stream_has_pendingPtr
      .asFunction<int Function(ffi.Pointer<GInputStream>)>();

  int g_input_stream_set_pending(
    ffi.Pointer<GInputStream> stream,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_input_stream_set_pending(
      stream,
      error,
    );
  }

  late final _g_input_stream_set_pendingPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GInputStream>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_input_stream_set_pending');
  late final _g_input_stream_set_pending =
      _g_input_stream_set_pendingPtr.asFunction<
          int Function(
              ffi.Pointer<GInputStream>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_input_stream_clear_pending(
    ffi.Pointer<GInputStream> stream,
  ) {
    return _g_input_stream_clear_pending(
      stream,
    );
  }

  late final _g_input_stream_clear_pendingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GInputStream>)>>(
          'g_input_stream_clear_pending');
  late final _g_input_stream_clear_pending = _g_input_stream_clear_pendingPtr
      .asFunction<void Function(ffi.Pointer<GInputStream>)>();

  int g_filter_input_stream_get_type() {
    return _g_filter_input_stream_get_type();
  }

  late final _g_filter_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_filter_input_stream_get_type');
  late final _g_filter_input_stream_get_type =
      _g_filter_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GInputStream> g_filter_input_stream_get_base_stream(
    ffi.Pointer<GFilterInputStream> stream,
  ) {
    return _g_filter_input_stream_get_base_stream(
      stream,
    );
  }

  late final _g_filter_input_stream_get_base_streamPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GInputStream> Function(
                  ffi.Pointer<GFilterInputStream>)>>(
      'g_filter_input_stream_get_base_stream');
  late final _g_filter_input_stream_get_base_stream =
      _g_filter_input_stream_get_base_streamPtr.asFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GFilterInputStream>)>();

  int g_filter_input_stream_get_close_base_stream(
    ffi.Pointer<GFilterInputStream> stream,
  ) {
    return _g_filter_input_stream_get_close_base_stream(
      stream,
    );
  }

  late final _g_filter_input_stream_get_close_base_streamPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFilterInputStream>)>>(
      'g_filter_input_stream_get_close_base_stream');
  late final _g_filter_input_stream_get_close_base_stream =
      _g_filter_input_stream_get_close_base_streamPtr
          .asFunction<int Function(ffi.Pointer<GFilterInputStream>)>();

  void g_filter_input_stream_set_close_base_stream(
    ffi.Pointer<GFilterInputStream> stream,
    int close_base,
  ) {
    return _g_filter_input_stream_set_close_base_stream(
      stream,
      close_base,
    );
  }

  late final _g_filter_input_stream_set_close_base_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GFilterInputStream>,
              gboolean)>>('g_filter_input_stream_set_close_base_stream');
  late final _g_filter_input_stream_set_close_base_stream =
      _g_filter_input_stream_set_close_base_streamPtr
          .asFunction<void Function(ffi.Pointer<GFilterInputStream>, int)>();

  int g_buffered_input_stream_get_type() {
    return _g_buffered_input_stream_get_type();
  }

  late final _g_buffered_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_buffered_input_stream_get_type');
  late final _g_buffered_input_stream_get_type =
      _g_buffered_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GInputStream> g_buffered_input_stream_new(
    ffi.Pointer<GInputStream> base_stream,
  ) {
    return _g_buffered_input_stream_new(
      base_stream,
    );
  }

  late final _g_buffered_input_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GInputStream>)>>('g_buffered_input_stream_new');
  late final _g_buffered_input_stream_new =
      _g_buffered_input_stream_newPtr.asFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<GInputStream>)>();

  ffi.Pointer<GInputStream> g_buffered_input_stream_new_sized(
    ffi.Pointer<GInputStream> base_stream,
    int size,
  ) {
    return _g_buffered_input_stream_new_sized(
      base_stream,
      size,
    );
  }

  late final _g_buffered_input_stream_new_sizedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<GInputStream>,
              gsize)>>('g_buffered_input_stream_new_sized');
  late final _g_buffered_input_stream_new_sized =
      _g_buffered_input_stream_new_sizedPtr.asFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<GInputStream>, int)>();

  int g_buffered_input_stream_get_buffer_size(
    ffi.Pointer<GBufferedInputStream> stream,
  ) {
    return _g_buffered_input_stream_get_buffer_size(
      stream,
    );
  }

  late final _g_buffered_input_stream_get_buffer_sizePtr = _lookup<
          ffi
          .NativeFunction<gsize Function(ffi.Pointer<GBufferedInputStream>)>>(
      'g_buffered_input_stream_get_buffer_size');
  late final _g_buffered_input_stream_get_buffer_size =
      _g_buffered_input_stream_get_buffer_sizePtr
          .asFunction<int Function(ffi.Pointer<GBufferedInputStream>)>();

  void g_buffered_input_stream_set_buffer_size(
    ffi.Pointer<GBufferedInputStream> stream,
    int size,
  ) {
    return _g_buffered_input_stream_set_buffer_size(
      stream,
      size,
    );
  }

  late final _g_buffered_input_stream_set_buffer_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GBufferedInputStream>,
              gsize)>>('g_buffered_input_stream_set_buffer_size');
  late final _g_buffered_input_stream_set_buffer_size =
      _g_buffered_input_stream_set_buffer_sizePtr
          .asFunction<void Function(ffi.Pointer<GBufferedInputStream>, int)>();

  int g_buffered_input_stream_get_available(
    ffi.Pointer<GBufferedInputStream> stream,
  ) {
    return _g_buffered_input_stream_get_available(
      stream,
    );
  }

  late final _g_buffered_input_stream_get_availablePtr = _lookup<
          ffi
          .NativeFunction<gsize Function(ffi.Pointer<GBufferedInputStream>)>>(
      'g_buffered_input_stream_get_available');
  late final _g_buffered_input_stream_get_available =
      _g_buffered_input_stream_get_availablePtr
          .asFunction<int Function(ffi.Pointer<GBufferedInputStream>)>();

  int g_buffered_input_stream_peek(
    ffi.Pointer<GBufferedInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int offset,
    int count,
  ) {
    return _g_buffered_input_stream_peek(
      stream,
      buffer,
      offset,
      count,
    );
  }

  late final _g_buffered_input_stream_peekPtr = _lookup<
      ffi.NativeFunction<
          gsize Function(
              ffi.Pointer<GBufferedInputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              gsize)>>('g_buffered_input_stream_peek');
  late final _g_buffered_input_stream_peek =
      _g_buffered_input_stream_peekPtr.asFunction<
          int Function(ffi.Pointer<GBufferedInputStream>, ffi.Pointer<ffi.Void>,
              int, int)>();

  ffi.Pointer<ffi.Void> g_buffered_input_stream_peek_buffer(
    ffi.Pointer<GBufferedInputStream> stream,
    ffi.Pointer<gsize> count,
  ) {
    return _g_buffered_input_stream_peek_buffer(
      stream,
      count,
    );
  }

  late final _g_buffered_input_stream_peek_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<GBufferedInputStream>,
              ffi.Pointer<gsize>)>>('g_buffered_input_stream_peek_buffer');
  late final _g_buffered_input_stream_peek_buffer =
      _g_buffered_input_stream_peek_bufferPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GBufferedInputStream>, ffi.Pointer<gsize>)>();

  int g_buffered_input_stream_fill(
    ffi.Pointer<GBufferedInputStream> stream,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_buffered_input_stream_fill(
      stream,
      count,
      cancellable,
      error,
    );
  }

  late final _g_buffered_input_stream_fillPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GBufferedInputStream>,
                  gssize,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_buffered_input_stream_fill');
  late final _g_buffered_input_stream_fill =
      _g_buffered_input_stream_fillPtr.asFunction<
          int Function(ffi.Pointer<GBufferedInputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_buffered_input_stream_fill_async(
    ffi.Pointer<GBufferedInputStream> stream,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_buffered_input_stream_fill_async(
      stream,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_buffered_input_stream_fill_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GBufferedInputStream>,
              gssize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_buffered_input_stream_fill_async');
  late final _g_buffered_input_stream_fill_async =
      _g_buffered_input_stream_fill_asyncPtr.asFunction<
          void Function(ffi.Pointer<GBufferedInputStream>, int, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_buffered_input_stream_fill_finish(
    ffi.Pointer<GBufferedInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_buffered_input_stream_fill_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_buffered_input_stream_fill_finishPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GBufferedInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_buffered_input_stream_fill_finish');
  late final _g_buffered_input_stream_fill_finish =
      _g_buffered_input_stream_fill_finishPtr.asFunction<
          int Function(ffi.Pointer<GBufferedInputStream>,
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_buffered_input_stream_read_byte(
    ffi.Pointer<GBufferedInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_buffered_input_stream_read_byte(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_buffered_input_stream_read_bytePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GBufferedInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_buffered_input_stream_read_byte');
  late final _g_buffered_input_stream_read_byte =
      _g_buffered_input_stream_read_bytePtr.asFunction<
          int Function(ffi.Pointer<GBufferedInputStream>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_get_type() {
    return _g_output_stream_get_type();
  }

  late final _g_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('g_output_stream_get_type');
  late final _g_output_stream_get_type =
      _g_output_stream_get_typePtr.asFunction<int Function()>();

  int g_output_stream_write(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write(
      stream,
      buffer,
      count,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_writePtr = _lookup<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_write');
  late final _g_output_stream_write = _g_output_stream_writePtr.asFunction<
      int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_write_all(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write_all(
      stream,
      buffer,
      count,
      bytes_written,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_write_allPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_write_all');
  late final _g_output_stream_write_all =
      _g_output_stream_write_allPtr.asFunction<
          int Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_writev(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GOutputVector> vectors,
    int n_vectors,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_writev(
      stream,
      vectors,
      n_vectors,
      bytes_written,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_writevPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              gsize,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_writev');
  late final _g_output_stream_writev = _g_output_stream_writevPtr.asFunction<
      int Function(
          ffi.Pointer<GOutputStream>,
          ffi.Pointer<GOutputVector>,
          int,
          ffi.Pointer<gsize>,
          ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_writev_all(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GOutputVector> vectors,
    int n_vectors,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_writev_all(
      stream,
      vectors,
      n_vectors,
      bytes_written,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_writev_allPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              gsize,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_writev_all');
  late final _g_output_stream_writev_all =
      _g_output_stream_writev_allPtr.asFunction<
          int Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              int,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_printf(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
    ffi.Pointer<gchar> format,
  ) {
    return _g_output_stream_printf(
      stream,
      bytes_written,
      cancellable,
      error,
      format,
    );
  }

  late final _g_output_stream_printfPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>,
              ffi.Pointer<gchar>)>>('g_output_stream_printf');
  late final _g_output_stream_printf = _g_output_stream_printfPtr.asFunction<
      int Function(
          ffi.Pointer<GOutputStream>,
          ffi.Pointer<gsize>,
          ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>,
          ffi.Pointer<gchar>)>();

  int g_output_stream_vprintf(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
    ffi.Pointer<gchar> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _g_output_stream_vprintf(
      stream,
      bytes_written,
      cancellable,
      error,
      format,
      args,
    );
  }

  late final _g_output_stream_vprintfPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>,
              ffi.Pointer<gchar>,
              ffi.Pointer<__va_list_tag>)>>('g_output_stream_vprintf');
  late final _g_output_stream_vprintf = _g_output_stream_vprintfPtr.asFunction<
      int Function(
          ffi.Pointer<GOutputStream>,
          ffi.Pointer<gsize>,
          ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>,
          ffi.Pointer<gchar>,
          ffi.Pointer<__va_list_tag>)>();

  int g_output_stream_write_bytes(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GBytes> bytes,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write_bytes(
      stream,
      bytes,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_write_bytesPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GBytes>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_write_bytes');
  late final _g_output_stream_write_bytes =
      _g_output_stream_write_bytesPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GBytes>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  Dartgssize g_output_stream_splice(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GInputStream> source,
    GOutputStreamSpliceFlags flags,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_splice(
      stream,
      source,
      flags.value,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_splicePtr = _lookup<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GInputStream>,
              ffi.UnsignedInt,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_splice');
  late final _g_output_stream_splice = _g_output_stream_splicePtr.asFunction<
      int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GInputStream>, int,
          ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_flush(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_flush(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_flushPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_flush');
  late final _g_output_stream_flush = _g_output_stream_flushPtr.asFunction<
      int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_close(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_close(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_output_stream_closePtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_output_stream_close');
  late final _g_output_stream_close = _g_output_stream_closePtr.asFunction<
      int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_write_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_write_async(
      stream,
      buffer,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_write_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_write_async');
  late final _g_output_stream_write_async =
      _g_output_stream_write_asyncPtr.asFunction<
          void Function(ffi.Pointer<GOutputStream>, ffi.Pointer<ffi.Void>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_output_stream_write_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_output_stream_write_finishPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_write_finish');
  late final _g_output_stream_write_finish =
      _g_output_stream_write_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_write_all_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_write_all_async(
      stream,
      buffer,
      count,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_write_all_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<ffi.Void>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_write_all_async');
  late final _g_output_stream_write_all_async =
      _g_output_stream_write_all_asyncPtr.asFunction<
          void Function(ffi.Pointer<GOutputStream>, ffi.Pointer<ffi.Void>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_output_stream_write_all_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write_all_finish(
      stream,
      result,
      bytes_written,
      error,
    );
  }

  late final _g_output_stream_write_all_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_write_all_finish');
  late final _g_output_stream_write_all_finish =
      _g_output_stream_write_all_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_writev_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GOutputVector> vectors,
    int n_vectors,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_writev_async(
      stream,
      vectors,
      n_vectors,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_writev_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_writev_async');
  late final _g_output_stream_writev_async =
      _g_output_stream_writev_asyncPtr.asFunction<
          void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              int,
              int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>();

  int g_output_stream_writev_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_writev_finish(
      stream,
      result,
      bytes_written,
      error,
    );
  }

  late final _g_output_stream_writev_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_writev_finish');
  late final _g_output_stream_writev_finish =
      _g_output_stream_writev_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_writev_all_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GOutputVector> vectors,
    int n_vectors,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_writev_all_async(
      stream,
      vectors,
      n_vectors,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_writev_all_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              gsize,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_writev_all_async');
  late final _g_output_stream_writev_all_async =
      _g_output_stream_writev_all_asyncPtr.asFunction<
          void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GOutputVector>,
              int,
              int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>();

  int g_output_stream_writev_all_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_writev_all_finish(
      stream,
      result,
      bytes_written,
      error,
    );
  }

  late final _g_output_stream_writev_all_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_writev_all_finish');
  late final _g_output_stream_writev_all_finish =
      _g_output_stream_writev_all_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_write_bytes_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GBytes> bytes,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_write_bytes_async(
      stream,
      bytes,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_write_bytes_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GBytes>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_write_bytes_async');
  late final _g_output_stream_write_bytes_async =
      _g_output_stream_write_bytes_asyncPtr.asFunction<
          void Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GBytes>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_output_stream_write_bytes_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_write_bytes_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_output_stream_write_bytes_finishPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_write_bytes_finish');
  late final _g_output_stream_write_bytes_finish =
      _g_output_stream_write_bytes_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_splice_async(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GInputStream> source,
    GOutputStreamSpliceFlags flags,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_splice_async(
      stream,
      source,
      flags.value,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_splice_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GInputStream>,
              ffi.UnsignedInt,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_splice_async');
  late final _g_output_stream_splice_async =
      _g_output_stream_splice_asyncPtr.asFunction<
          void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Pointer<GInputStream>,
              int,
              int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>();

  int g_output_stream_splice_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_splice_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_output_stream_splice_finishPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_splice_finish');
  late final _g_output_stream_splice_finish =
      _g_output_stream_splice_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_flush_async(
    ffi.Pointer<GOutputStream> stream,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_flush_async(
      stream,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_flush_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_flush_async');
  late final _g_output_stream_flush_async =
      _g_output_stream_flush_asyncPtr.asFunction<
          void Function(ffi.Pointer<GOutputStream>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_output_stream_flush_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_flush_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_output_stream_flush_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_flush_finish');
  late final _g_output_stream_flush_finish =
      _g_output_stream_flush_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_close_async(
    ffi.Pointer<GOutputStream> stream,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_output_stream_close_async(
      stream,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_output_stream_close_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_output_stream_close_async');
  late final _g_output_stream_close_async =
      _g_output_stream_close_asyncPtr.asFunction<
          void Function(ffi.Pointer<GOutputStream>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_output_stream_close_finish(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_close_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_output_stream_close_finishPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_close_finish');
  late final _g_output_stream_close_finish =
      _g_output_stream_close_finishPtr.asFunction<
          int Function(ffi.Pointer<GOutputStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_output_stream_is_closed(
    ffi.Pointer<GOutputStream> stream,
  ) {
    return _g_output_stream_is_closed(
      stream,
    );
  }

  late final _g_output_stream_is_closedPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GOutputStream>)>>(
      'g_output_stream_is_closed');
  late final _g_output_stream_is_closed = _g_output_stream_is_closedPtr
      .asFunction<int Function(ffi.Pointer<GOutputStream>)>();

  int g_output_stream_is_closing(
    ffi.Pointer<GOutputStream> stream,
  ) {
    return _g_output_stream_is_closing(
      stream,
    );
  }

  late final _g_output_stream_is_closingPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GOutputStream>)>>(
      'g_output_stream_is_closing');
  late final _g_output_stream_is_closing = _g_output_stream_is_closingPtr
      .asFunction<int Function(ffi.Pointer<GOutputStream>)>();

  int g_output_stream_has_pending(
    ffi.Pointer<GOutputStream> stream,
  ) {
    return _g_output_stream_has_pending(
      stream,
    );
  }

  late final _g_output_stream_has_pendingPtr = _lookup<
          ffi.NativeFunction<gboolean Function(ffi.Pointer<GOutputStream>)>>(
      'g_output_stream_has_pending');
  late final _g_output_stream_has_pending = _g_output_stream_has_pendingPtr
      .asFunction<int Function(ffi.Pointer<GOutputStream>)>();

  int g_output_stream_set_pending(
    ffi.Pointer<GOutputStream> stream,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_output_stream_set_pending(
      stream,
      error,
    );
  }

  late final _g_output_stream_set_pendingPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GOutputStream>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_output_stream_set_pending');
  late final _g_output_stream_set_pending =
      _g_output_stream_set_pendingPtr.asFunction<
          int Function(
              ffi.Pointer<GOutputStream>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_output_stream_clear_pending(
    ffi.Pointer<GOutputStream> stream,
  ) {
    return _g_output_stream_clear_pending(
      stream,
    );
  }

  late final _g_output_stream_clear_pendingPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GOutputStream>)>>(
      'g_output_stream_clear_pending');
  late final _g_output_stream_clear_pending = _g_output_stream_clear_pendingPtr
      .asFunction<void Function(ffi.Pointer<GOutputStream>)>();

  int g_filter_output_stream_get_type() {
    return _g_filter_output_stream_get_type();
  }

  late final _g_filter_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_filter_output_stream_get_type');
  late final _g_filter_output_stream_get_type =
      _g_filter_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GOutputStream> g_filter_output_stream_get_base_stream(
    ffi.Pointer<GFilterOutputStream> stream,
  ) {
    return _g_filter_output_stream_get_base_stream(
      stream,
    );
  }

  late final _g_filter_output_stream_get_base_streamPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GOutputStream> Function(
                  ffi.Pointer<GFilterOutputStream>)>>(
      'g_filter_output_stream_get_base_stream');
  late final _g_filter_output_stream_get_base_stream =
      _g_filter_output_stream_get_base_streamPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GFilterOutputStream>)>();

  int g_filter_output_stream_get_close_base_stream(
    ffi.Pointer<GFilterOutputStream> stream,
  ) {
    return _g_filter_output_stream_get_close_base_stream(
      stream,
    );
  }

  late final _g_filter_output_stream_get_close_base_streamPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFilterOutputStream>)>>(
      'g_filter_output_stream_get_close_base_stream');
  late final _g_filter_output_stream_get_close_base_stream =
      _g_filter_output_stream_get_close_base_streamPtr
          .asFunction<int Function(ffi.Pointer<GFilterOutputStream>)>();

  void g_filter_output_stream_set_close_base_stream(
    ffi.Pointer<GFilterOutputStream> stream,
    int close_base,
  ) {
    return _g_filter_output_stream_set_close_base_stream(
      stream,
      close_base,
    );
  }

  late final _g_filter_output_stream_set_close_base_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GFilterOutputStream>,
              gboolean)>>('g_filter_output_stream_set_close_base_stream');
  late final _g_filter_output_stream_set_close_base_stream =
      _g_filter_output_stream_set_close_base_streamPtr
          .asFunction<void Function(ffi.Pointer<GFilterOutputStream>, int)>();

  int g_buffered_output_stream_get_type() {
    return _g_buffered_output_stream_get_type();
  }

  late final _g_buffered_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_buffered_output_stream_get_type');
  late final _g_buffered_output_stream_get_type =
      _g_buffered_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GOutputStream> g_buffered_output_stream_new(
    ffi.Pointer<GOutputStream> base_stream,
  ) {
    return _g_buffered_output_stream_new(
      base_stream,
    );
  }

  late final _g_buffered_output_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GOutputStream>)>>('g_buffered_output_stream_new');
  late final _g_buffered_output_stream_new =
      _g_buffered_output_stream_newPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(ffi.Pointer<GOutputStream>)>();

  ffi.Pointer<GOutputStream> g_buffered_output_stream_new_sized(
    ffi.Pointer<GOutputStream> base_stream,
    int size,
  ) {
    return _g_buffered_output_stream_new_sized(
      base_stream,
      size,
    );
  }

  late final _g_buffered_output_stream_new_sizedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(ffi.Pointer<GOutputStream>,
              gsize)>>('g_buffered_output_stream_new_sized');
  late final _g_buffered_output_stream_new_sized =
      _g_buffered_output_stream_new_sizedPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GOutputStream>, int)>();

  int g_buffered_output_stream_get_buffer_size(
    ffi.Pointer<GBufferedOutputStream> stream,
  ) {
    return _g_buffered_output_stream_get_buffer_size(
      stream,
    );
  }

  late final _g_buffered_output_stream_get_buffer_sizePtr = _lookup<
          ffi
          .NativeFunction<gsize Function(ffi.Pointer<GBufferedOutputStream>)>>(
      'g_buffered_output_stream_get_buffer_size');
  late final _g_buffered_output_stream_get_buffer_size =
      _g_buffered_output_stream_get_buffer_sizePtr
          .asFunction<int Function(ffi.Pointer<GBufferedOutputStream>)>();

  void g_buffered_output_stream_set_buffer_size(
    ffi.Pointer<GBufferedOutputStream> stream,
    int size,
  ) {
    return _g_buffered_output_stream_set_buffer_size(
      stream,
      size,
    );
  }

  late final _g_buffered_output_stream_set_buffer_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GBufferedOutputStream>,
              gsize)>>('g_buffered_output_stream_set_buffer_size');
  late final _g_buffered_output_stream_set_buffer_size =
      _g_buffered_output_stream_set_buffer_sizePtr
          .asFunction<void Function(ffi.Pointer<GBufferedOutputStream>, int)>();

  int g_buffered_output_stream_get_auto_grow(
    ffi.Pointer<GBufferedOutputStream> stream,
  ) {
    return _g_buffered_output_stream_get_auto_grow(
      stream,
    );
  }

  late final _g_buffered_output_stream_get_auto_growPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GBufferedOutputStream>)>>(
      'g_buffered_output_stream_get_auto_grow');
  late final _g_buffered_output_stream_get_auto_grow =
      _g_buffered_output_stream_get_auto_growPtr
          .asFunction<int Function(ffi.Pointer<GBufferedOutputStream>)>();

  void g_buffered_output_stream_set_auto_grow(
    ffi.Pointer<GBufferedOutputStream> stream,
    int auto_grow,
  ) {
    return _g_buffered_output_stream_set_auto_grow(
      stream,
      auto_grow,
    );
  }

  late final _g_buffered_output_stream_set_auto_growPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GBufferedOutputStream>,
              gboolean)>>('g_buffered_output_stream_set_auto_grow');
  late final _g_buffered_output_stream_set_auto_grow =
      _g_buffered_output_stream_set_auto_growPtr
          .asFunction<void Function(ffi.Pointer<GBufferedOutputStream>, int)>();

  int g_converter_input_stream_get_type() {
    return _g_converter_input_stream_get_type();
  }

  late final _g_converter_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_converter_input_stream_get_type');
  late final _g_converter_input_stream_get_type =
      _g_converter_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GInputStream> g_converter_input_stream_new(
    ffi.Pointer<GInputStream> base_stream,
    ffi.Pointer<GConverter> converter,
  ) {
    return _g_converter_input_stream_new(
      base_stream,
      converter,
    );
  }

  late final _g_converter_input_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<GInputStream>,
              ffi.Pointer<GConverter>)>>('g_converter_input_stream_new');
  late final _g_converter_input_stream_new =
      _g_converter_input_stream_newPtr.asFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GInputStream>, ffi.Pointer<GConverter>)>();

  ffi.Pointer<GConverter> g_converter_input_stream_get_converter(
    ffi.Pointer<GConverterInputStream> converter_stream,
  ) {
    return _g_converter_input_stream_get_converter(
      converter_stream,
    );
  }

  late final _g_converter_input_stream_get_converterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GConverter> Function(
                  ffi.Pointer<GConverterInputStream>)>>(
      'g_converter_input_stream_get_converter');
  late final _g_converter_input_stream_get_converter =
      _g_converter_input_stream_get_converterPtr.asFunction<
          ffi.Pointer<GConverter> Function(
              ffi.Pointer<GConverterInputStream>)>();

  int g_converter_output_stream_get_type() {
    return _g_converter_output_stream_get_type();
  }

  late final _g_converter_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_converter_output_stream_get_type');
  late final _g_converter_output_stream_get_type =
      _g_converter_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GOutputStream> g_converter_output_stream_new(
    ffi.Pointer<GOutputStream> base_stream,
    ffi.Pointer<GConverter> converter,
  ) {
    return _g_converter_output_stream_new(
      base_stream,
      converter,
    );
  }

  late final _g_converter_output_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(ffi.Pointer<GOutputStream>,
              ffi.Pointer<GConverter>)>>('g_converter_output_stream_new');
  late final _g_converter_output_stream_new =
      _g_converter_output_stream_newPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GOutputStream>, ffi.Pointer<GConverter>)>();

  ffi.Pointer<GConverter> g_converter_output_stream_get_converter(
    ffi.Pointer<GConverterOutputStream> converter_stream,
  ) {
    return _g_converter_output_stream_get_converter(
      converter_stream,
    );
  }

  late final _g_converter_output_stream_get_converterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GConverter> Function(
                  ffi.Pointer<GConverterOutputStream>)>>(
      'g_converter_output_stream_get_converter');
  late final _g_converter_output_stream_get_converter =
      _g_converter_output_stream_get_converterPtr.asFunction<
          ffi.Pointer<GConverter> Function(
              ffi.Pointer<GConverterOutputStream>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _optarg =
      _lookup<ffi.Pointer<ffi.Char>>('optarg');

  ffi.Pointer<ffi.Char> get optarg => _optarg.value;

  set optarg(ffi.Pointer<ffi.Char> value) => _optarg.value = value;

  late final ffi.Pointer<ffi.Int> _optind = _lookup<ffi.Int>('optind');

  int get optind => _optind.value;

  set optind(int value) => _optind.value = value;

  late final ffi.Pointer<ffi.Int> _opterr = _lookup<ffi.Int>('opterr');

  int get opterr => _opterr.value;

  set opterr(int value) => _opterr.value = value;

  late final ffi.Pointer<ffi.Int> _optopt = _lookup<ffi.Int>('optopt');

  int get optopt => _optopt.value;

  set optopt(int value) => _optopt.value = value;

  int getopt(
    int ___argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> ___argv,
    ffi.Pointer<ffi.Char> __shortopts,
  ) {
    return _getopt(
      ___argc,
      ___argv,
      __shortopts,
    );
  }

  late final _getoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('getopt');
  late final _getopt = _getoptPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int g_data_input_stream_get_type() {
    return _g_data_input_stream_get_type();
  }

  late final _g_data_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_data_input_stream_get_type');
  late final _g_data_input_stream_get_type =
      _g_data_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GDataInputStream> g_data_input_stream_new(
    ffi.Pointer<GInputStream> base_stream,
  ) {
    return _g_data_input_stream_new(
      base_stream,
    );
  }

  late final _g_data_input_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GDataInputStream> Function(
              ffi.Pointer<GInputStream>)>>('g_data_input_stream_new');
  late final _g_data_input_stream_new = _g_data_input_stream_newPtr.asFunction<
      ffi.Pointer<GDataInputStream> Function(ffi.Pointer<GInputStream>)>();

  void g_data_input_stream_set_byte_order(
    ffi.Pointer<GDataInputStream> stream,
    GDataStreamByteOrder order,
  ) {
    return _g_data_input_stream_set_byte_order(
      stream,
      order.value,
    );
  }

  late final _g_data_input_stream_set_byte_orderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDataInputStream>,
              ffi.UnsignedInt)>>('g_data_input_stream_set_byte_order');
  late final _g_data_input_stream_set_byte_order =
      _g_data_input_stream_set_byte_orderPtr
          .asFunction<void Function(ffi.Pointer<GDataInputStream>, int)>();

  GDataStreamByteOrder g_data_input_stream_get_byte_order(
    ffi.Pointer<GDataInputStream> stream,
  ) {
    return GDataStreamByteOrder.fromValue(_g_data_input_stream_get_byte_order(
      stream,
    ));
  }

  late final _g_data_input_stream_get_byte_orderPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<GDataInputStream>)>>(
      'g_data_input_stream_get_byte_order');
  late final _g_data_input_stream_get_byte_order =
      _g_data_input_stream_get_byte_orderPtr
          .asFunction<int Function(ffi.Pointer<GDataInputStream>)>();

  void g_data_input_stream_set_newline_type(
    ffi.Pointer<GDataInputStream> stream,
    GDataStreamNewlineType type,
  ) {
    return _g_data_input_stream_set_newline_type(
      stream,
      type.value,
    );
  }

  late final _g_data_input_stream_set_newline_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDataInputStream>,
              ffi.UnsignedInt)>>('g_data_input_stream_set_newline_type');
  late final _g_data_input_stream_set_newline_type =
      _g_data_input_stream_set_newline_typePtr
          .asFunction<void Function(ffi.Pointer<GDataInputStream>, int)>();

  GDataStreamNewlineType g_data_input_stream_get_newline_type(
    ffi.Pointer<GDataInputStream> stream,
  ) {
    return GDataStreamNewlineType.fromValue(
        _g_data_input_stream_get_newline_type(
      stream,
    ));
  }

  late final _g_data_input_stream_get_newline_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<GDataInputStream>)>>(
      'g_data_input_stream_get_newline_type');
  late final _g_data_input_stream_get_newline_type =
      _g_data_input_stream_get_newline_typePtr
          .asFunction<int Function(ffi.Pointer<GDataInputStream>)>();

  int g_data_input_stream_read_byte(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_byte(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_bytePtr = _lookup<
          ffi.NativeFunction<
              guchar Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_byte');
  late final _g_data_input_stream_read_byte =
      _g_data_input_stream_read_bytePtr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_int16(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_int16(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_int16Ptr = _lookup<
          ffi.NativeFunction<
              gint16 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_int16');
  late final _g_data_input_stream_read_int16 =
      _g_data_input_stream_read_int16Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_uint16(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_uint16(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_uint16Ptr = _lookup<
          ffi.NativeFunction<
              guint16 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_uint16');
  late final _g_data_input_stream_read_uint16 =
      _g_data_input_stream_read_uint16Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_int32(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_int32(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_int32Ptr = _lookup<
          ffi.NativeFunction<
              gint32 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_int32');
  late final _g_data_input_stream_read_int32 =
      _g_data_input_stream_read_int32Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_uint32(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_uint32(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_uint32Ptr = _lookup<
          ffi.NativeFunction<
              guint32 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_uint32');
  late final _g_data_input_stream_read_uint32 =
      _g_data_input_stream_read_uint32Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_int64(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_int64(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_int64Ptr = _lookup<
          ffi.NativeFunction<
              gint64 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_int64');
  late final _g_data_input_stream_read_int64 =
      _g_data_input_stream_read_int64Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_input_stream_read_uint64(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_uint64(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_uint64Ptr = _lookup<
          ffi.NativeFunction<
              guint64 Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_uint64');
  late final _g_data_input_stream_read_uint64 =
      _g_data_input_stream_read_uint64Ptr.asFunction<
          int Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_line(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gsize> length,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_line(
      stream,
      length,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_linePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_line');
  late final _g_data_input_stream_read_line =
      _g_data_input_stream_read_linePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_line_utf8(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gsize> length,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_line_utf8(
      stream,
      length,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_line_utf8Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_line_utf8');
  late final _g_data_input_stream_read_line_utf8 =
      _g_data_input_stream_read_line_utf8Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_data_input_stream_read_line_async(
    ffi.Pointer<GDataInputStream> stream,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_data_input_stream_read_line_async(
      stream,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_data_input_stream_read_line_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDataInputStream>,
              gint,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_data_input_stream_read_line_async');
  late final _g_data_input_stream_read_line_async =
      _g_data_input_stream_read_line_asyncPtr.asFunction<
          void Function(ffi.Pointer<GDataInputStream>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_line_finish(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> length,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_line_finish(
      stream,
      result,
      length,
      error,
    );
  }

  late final _g_data_input_stream_read_line_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_line_finish');
  late final _g_data_input_stream_read_line_finish =
      _g_data_input_stream_read_line_finishPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_line_finish_utf8(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> length,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_line_finish_utf8(
      stream,
      result,
      length,
      error,
    );
  }

  late final _g_data_input_stream_read_line_finish_utf8Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_line_finish_utf8');
  late final _g_data_input_stream_read_line_finish_utf8 =
      _g_data_input_stream_read_line_finish_utf8Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_until(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gchar> stop_chars,
    ffi.Pointer<gsize> length,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_until(
      stream,
      stop_chars,
      length,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_untilPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<gchar>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_until');
  late final _g_data_input_stream_read_until =
      _g_data_input_stream_read_untilPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gchar>,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_data_input_stream_read_until_async(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gchar> stop_chars,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_data_input_stream_read_until_async(
      stream,
      stop_chars,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_data_input_stream_read_until_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gchar>,
              gint,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_data_input_stream_read_until_async');
  late final _g_data_input_stream_read_until_async =
      _g_data_input_stream_read_until_asyncPtr.asFunction<
          void Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<gchar>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_until_finish(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> length,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_until_finish(
      stream,
      result,
      length,
      error,
    );
  }

  late final _g_data_input_stream_read_until_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_until_finish');
  late final _g_data_input_stream_read_until_finish =
      _g_data_input_stream_read_until_finishPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_upto(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gchar> stop_chars,
    int stop_chars_len,
    ffi.Pointer<gsize> length,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_upto(
      stream,
      stop_chars,
      stop_chars_len,
      length,
      cancellable,
      error,
    );
  }

  late final _g_data_input_stream_read_uptoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<gchar>,
                  gssize,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_upto');
  late final _g_data_input_stream_read_upto =
      _g_data_input_stream_read_uptoPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gchar>,
              int,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_data_input_stream_read_upto_async(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<gchar> stop_chars,
    int stop_chars_len,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_data_input_stream_read_upto_async(
      stream,
      stop_chars,
      stop_chars_len,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_data_input_stream_read_upto_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<gchar>,
              gssize,
              gint,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_data_input_stream_read_upto_async');
  late final _g_data_input_stream_read_upto_async =
      _g_data_input_stream_read_upto_asyncPtr.asFunction<
          void Function(ffi.Pointer<GDataInputStream>, ffi.Pointer<gchar>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<ffi.Char> g_data_input_stream_read_upto_finish(
    ffi.Pointer<GDataInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<gsize> length,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_input_stream_read_upto_finish(
      stream,
      result,
      length,
      error,
    );
  }

  late final _g_data_input_stream_read_upto_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<GDataInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_input_stream_read_upto_finish');
  late final _g_data_input_stream_read_upto_finish =
      _g_data_input_stream_read_upto_finishPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GDataInputStream>,
              ffi.Pointer<GAsyncResult>,
              ffi.Pointer<gsize>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_get_type() {
    return _g_data_output_stream_get_type();
  }

  late final _g_data_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_data_output_stream_get_type');
  late final _g_data_output_stream_get_type =
      _g_data_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GDataOutputStream> g_data_output_stream_new(
    ffi.Pointer<GOutputStream> base_stream,
  ) {
    return _g_data_output_stream_new(
      base_stream,
    );
  }

  late final _g_data_output_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GDataOutputStream> Function(
              ffi.Pointer<GOutputStream>)>>('g_data_output_stream_new');
  late final _g_data_output_stream_new =
      _g_data_output_stream_newPtr.asFunction<
          ffi.Pointer<GDataOutputStream> Function(
              ffi.Pointer<GOutputStream>)>();

  void g_data_output_stream_set_byte_order(
    ffi.Pointer<GDataOutputStream> stream,
    GDataStreamByteOrder order,
  ) {
    return _g_data_output_stream_set_byte_order(
      stream,
      order.value,
    );
  }

  late final _g_data_output_stream_set_byte_orderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GDataOutputStream>,
              ffi.UnsignedInt)>>('g_data_output_stream_set_byte_order');
  late final _g_data_output_stream_set_byte_order =
      _g_data_output_stream_set_byte_orderPtr
          .asFunction<void Function(ffi.Pointer<GDataOutputStream>, int)>();

  GDataStreamByteOrder g_data_output_stream_get_byte_order(
    ffi.Pointer<GDataOutputStream> stream,
  ) {
    return GDataStreamByteOrder.fromValue(_g_data_output_stream_get_byte_order(
      stream,
    ));
  }

  late final _g_data_output_stream_get_byte_orderPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<GDataOutputStream>)>>(
      'g_data_output_stream_get_byte_order');
  late final _g_data_output_stream_get_byte_order =
      _g_data_output_stream_get_byte_orderPtr
          .asFunction<int Function(ffi.Pointer<GDataOutputStream>)>();

  int g_data_output_stream_put_byte(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_byte(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_bytePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  guchar,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_byte');
  late final _g_data_output_stream_put_byte =
      _g_data_output_stream_put_bytePtr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_int16(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_int16(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_int16Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  gint16,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_int16');
  late final _g_data_output_stream_put_int16 =
      _g_data_output_stream_put_int16Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_uint16(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_uint16(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_uint16Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  guint16,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_uint16');
  late final _g_data_output_stream_put_uint16 =
      _g_data_output_stream_put_uint16Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_int32(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_int32(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_int32Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  gint32,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_int32');
  late final _g_data_output_stream_put_int32 =
      _g_data_output_stream_put_int32Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_uint32(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_uint32(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_uint32Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  guint32,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_uint32');
  late final _g_data_output_stream_put_uint32 =
      _g_data_output_stream_put_uint32Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_int64(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_int64(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_int64Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  gint64,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_int64');
  late final _g_data_output_stream_put_int64 =
      _g_data_output_stream_put_int64Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_uint64(
    ffi.Pointer<GDataOutputStream> stream,
    int data,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_uint64(
      stream,
      data,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_uint64Ptr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  guint64,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_uint64');
  late final _g_data_output_stream_put_uint64 =
      _g_data_output_stream_put_uint64Ptr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, int,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_data_output_stream_put_string(
    ffi.Pointer<GDataOutputStream> stream,
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_data_output_stream_put_string(
      stream,
      str,
      cancellable,
      error,
    );
  }

  late final _g_data_output_stream_put_stringPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GDataOutputStream>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_data_output_stream_put_string');
  late final _g_data_output_stream_put_string =
      _g_data_output_stream_put_stringPtr.asFunction<
          int Function(ffi.Pointer<GDataOutputStream>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_file_input_stream_get_type() {
    return _g_file_input_stream_get_type();
  }

  late final _g_file_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_file_input_stream_get_type');
  late final _g_file_input_stream_get_type =
      _g_file_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GFileInfo> g_file_input_stream_query_info(
    ffi.Pointer<GFileInputStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_input_stream_query_info(
      stream,
      attributes,
      cancellable,
      error,
    );
  }

  late final _g_file_input_stream_query_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileInputStream>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_input_stream_query_info');
  late final _g_file_input_stream_query_info =
      _g_file_input_stream_query_infoPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileInputStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_file_input_stream_query_info_async(
    ffi.Pointer<GFileInputStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_file_input_stream_query_info_async(
      stream,
      attributes,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_file_input_stream_query_info_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileInputStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_file_input_stream_query_info_async');
  late final _g_file_input_stream_query_info_async =
      _g_file_input_stream_query_info_asyncPtr.asFunction<
          void Function(ffi.Pointer<GFileInputStream>, ffi.Pointer<ffi.Char>,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<GFileInfo> g_file_input_stream_query_info_finish(
    ffi.Pointer<GFileInputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_input_stream_query_info_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_file_input_stream_query_info_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileInputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_input_stream_query_info_finish');
  late final _g_file_input_stream_query_info_finish =
      _g_file_input_stream_query_info_finishPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(ffi.Pointer<GFileInputStream>,
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_io_stream_get_type() {
    return _g_io_stream_get_type();
  }

  late final _g_io_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('g_io_stream_get_type');
  late final _g_io_stream_get_type =
      _g_io_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GInputStream> g_io_stream_get_input_stream(
    ffi.Pointer<GIOStream> stream,
  ) {
    return _g_io_stream_get_input_stream(
      stream,
    );
  }

  late final _g_io_stream_get_input_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GIOStream>)>>('g_io_stream_get_input_stream');
  late final _g_io_stream_get_input_stream = _g_io_stream_get_input_streamPtr
      .asFunction<ffi.Pointer<GInputStream> Function(ffi.Pointer<GIOStream>)>();

  ffi.Pointer<GOutputStream> g_io_stream_get_output_stream(
    ffi.Pointer<GIOStream> stream,
  ) {
    return _g_io_stream_get_output_stream(
      stream,
    );
  }

  late final _g_io_stream_get_output_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GIOStream>)>>('g_io_stream_get_output_stream');
  late final _g_io_stream_get_output_stream =
      _g_io_stream_get_output_streamPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(ffi.Pointer<GIOStream>)>();

  void g_io_stream_splice_async(
    ffi.Pointer<GIOStream> stream1,
    ffi.Pointer<GIOStream> stream2,
    GIOStreamSpliceFlags flags,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_io_stream_splice_async(
      stream1,
      stream2,
      flags.value,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_io_stream_splice_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GIOStream>,
              ffi.Pointer<GIOStream>,
              ffi.UnsignedInt,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_io_stream_splice_async');
  late final _g_io_stream_splice_async =
      _g_io_stream_splice_asyncPtr.asFunction<
          void Function(ffi.Pointer<GIOStream>, ffi.Pointer<GIOStream>, int,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  int g_io_stream_splice_finish(
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_io_stream_splice_finish(
      result,
      error,
    );
  }

  late final _g_io_stream_splice_finishPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_io_stream_splice_finish');
  late final _g_io_stream_splice_finish =
      _g_io_stream_splice_finishPtr.asFunction<
          int Function(
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_io_stream_close(
    ffi.Pointer<GIOStream> stream,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_io_stream_close(
      stream,
      cancellable,
      error,
    );
  }

  late final _g_io_stream_closePtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GIOStream>, ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_io_stream_close');
  late final _g_io_stream_close = _g_io_stream_closePtr.asFunction<
      int Function(ffi.Pointer<GIOStream>, ffi.Pointer<GCancellable>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_io_stream_close_async(
    ffi.Pointer<GIOStream> stream,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_io_stream_close_async(
      stream,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_io_stream_close_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GIOStream>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_io_stream_close_async');
  late final _g_io_stream_close_async = _g_io_stream_close_asyncPtr.asFunction<
      void Function(ffi.Pointer<GIOStream>, int, ffi.Pointer<GCancellable>,
          GAsyncReadyCallback, gpointer)>();

  int g_io_stream_close_finish(
    ffi.Pointer<GIOStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_io_stream_close_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_io_stream_close_finishPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GIOStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_io_stream_close_finish');
  late final _g_io_stream_close_finish =
      _g_io_stream_close_finishPtr.asFunction<
          int Function(ffi.Pointer<GIOStream>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_io_stream_is_closed(
    ffi.Pointer<GIOStream> stream,
  ) {
    return _g_io_stream_is_closed(
      stream,
    );
  }

  late final _g_io_stream_is_closedPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<GIOStream>)>>(
          'g_io_stream_is_closed');
  late final _g_io_stream_is_closed = _g_io_stream_is_closedPtr
      .asFunction<int Function(ffi.Pointer<GIOStream>)>();

  int g_io_stream_has_pending(
    ffi.Pointer<GIOStream> stream,
  ) {
    return _g_io_stream_has_pending(
      stream,
    );
  }

  late final _g_io_stream_has_pendingPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<GIOStream>)>>(
          'g_io_stream_has_pending');
  late final _g_io_stream_has_pending = _g_io_stream_has_pendingPtr
      .asFunction<int Function(ffi.Pointer<GIOStream>)>();

  int g_io_stream_set_pending(
    ffi.Pointer<GIOStream> stream,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_io_stream_set_pending(
      stream,
      error,
    );
  }

  late final _g_io_stream_set_pendingPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GIOStream>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('g_io_stream_set_pending');
  late final _g_io_stream_set_pending = _g_io_stream_set_pendingPtr.asFunction<
      int Function(ffi.Pointer<GIOStream>, ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_io_stream_clear_pending(
    ffi.Pointer<GIOStream> stream,
  ) {
    return _g_io_stream_clear_pending(
      stream,
    );
  }

  late final _g_io_stream_clear_pendingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GIOStream>)>>(
          'g_io_stream_clear_pending');
  late final _g_io_stream_clear_pending = _g_io_stream_clear_pendingPtr
      .asFunction<void Function(ffi.Pointer<GIOStream>)>();

  int g_file_io_stream_get_type() {
    return _g_file_io_stream_get_type();
  }

  late final _g_file_io_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_file_io_stream_get_type');
  late final _g_file_io_stream_get_type =
      _g_file_io_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GFileInfo> g_file_io_stream_query_info(
    ffi.Pointer<GFileIOStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_io_stream_query_info(
      stream,
      attributes,
      cancellable,
      error,
    );
  }

  late final _g_file_io_stream_query_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileIOStream>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_io_stream_query_info');
  late final _g_file_io_stream_query_info =
      _g_file_io_stream_query_infoPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileIOStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_file_io_stream_query_info_async(
    ffi.Pointer<GFileIOStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_file_io_stream_query_info_async(
      stream,
      attributes,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_file_io_stream_query_info_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileIOStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_file_io_stream_query_info_async');
  late final _g_file_io_stream_query_info_async =
      _g_file_io_stream_query_info_asyncPtr.asFunction<
          void Function(ffi.Pointer<GFileIOStream>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<GFileInfo> g_file_io_stream_query_info_finish(
    ffi.Pointer<GFileIOStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_io_stream_query_info_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_file_io_stream_query_info_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileIOStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_io_stream_query_info_finish');
  late final _g_file_io_stream_query_info_finish =
      _g_file_io_stream_query_info_finishPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(ffi.Pointer<GFileIOStream>,
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_file_io_stream_get_etag(
    ffi.Pointer<GFileIOStream> stream,
  ) {
    return _g_file_io_stream_get_etag(
      stream,
    );
  }

  late final _g_file_io_stream_get_etagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GFileIOStream>)>>('g_file_io_stream_get_etag');
  late final _g_file_io_stream_get_etag = _g_file_io_stream_get_etagPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFileIOStream>)>();

  int g_file_output_stream_get_type() {
    return _g_file_output_stream_get_type();
  }

  late final _g_file_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_file_output_stream_get_type');
  late final _g_file_output_stream_get_type =
      _g_file_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GFileInfo> g_file_output_stream_query_info(
    ffi.Pointer<GFileOutputStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_output_stream_query_info(
      stream,
      attributes,
      cancellable,
      error,
    );
  }

  late final _g_file_output_stream_query_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileOutputStream>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_output_stream_query_info');
  late final _g_file_output_stream_query_info =
      _g_file_output_stream_query_infoPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileOutputStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_file_output_stream_query_info_async(
    ffi.Pointer<GFileOutputStream> stream,
    ffi.Pointer<ffi.Char> attributes,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _g_file_output_stream_query_info_async(
      stream,
      attributes,
      io_priority,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _g_file_output_stream_query_info_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileOutputStream>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<GCancellable>,
              GAsyncReadyCallback,
              gpointer)>>('g_file_output_stream_query_info_async');
  late final _g_file_output_stream_query_info_async =
      _g_file_output_stream_query_info_asyncPtr.asFunction<
          void Function(ffi.Pointer<GFileOutputStream>, ffi.Pointer<ffi.Char>,
              int, ffi.Pointer<GCancellable>, GAsyncReadyCallback, gpointer)>();

  ffi.Pointer<GFileInfo> g_file_output_stream_query_info_finish(
    ffi.Pointer<GFileOutputStream> stream,
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_file_output_stream_query_info_finish(
      stream,
      result,
      error,
    );
  }

  late final _g_file_output_stream_query_info_finishPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GFileInfo> Function(
                  ffi.Pointer<GFileOutputStream>,
                  ffi.Pointer<GAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_file_output_stream_query_info_finish');
  late final _g_file_output_stream_query_info_finish =
      _g_file_output_stream_query_info_finishPtr.asFunction<
          ffi.Pointer<GFileInfo> Function(ffi.Pointer<GFileOutputStream>,
              ffi.Pointer<GAsyncResult>, ffi.Pointer<ffi.Pointer<GError>>)>();

  ffi.Pointer<ffi.Char> g_file_output_stream_get_etag(
    ffi.Pointer<GFileOutputStream> stream,
  ) {
    return _g_file_output_stream_get_etag(
      stream,
    );
  }

  late final _g_file_output_stream_get_etagPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFileOutputStream>)>>(
      'g_file_output_stream_get_etag');
  late final _g_file_output_stream_get_etag =
      _g_file_output_stream_get_etagPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<GFileOutputStream>)>();

  int g_memory_input_stream_get_type() {
    return _g_memory_input_stream_get_type();
  }

  late final _g_memory_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_memory_input_stream_get_type');
  late final _g_memory_input_stream_get_type =
      _g_memory_input_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GInputStream> g_memory_input_stream_new() {
    return _g_memory_input_stream_new();
  }

  late final _g_memory_input_stream_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GInputStream> Function()>>(
          'g_memory_input_stream_new');
  late final _g_memory_input_stream_new = _g_memory_input_stream_newPtr
      .asFunction<ffi.Pointer<GInputStream> Function()>();

  ffi.Pointer<GInputStream> g_memory_input_stream_new_from_data(
    ffi.Pointer<ffi.Void> data,
    int len,
    GDestroyNotify destroy,
  ) {
    return _g_memory_input_stream_new_from_data(
      data,
      len,
      destroy,
    );
  }

  late final _g_memory_input_stream_new_from_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<ffi.Void>, gssize,
              GDestroyNotify)>>('g_memory_input_stream_new_from_data');
  late final _g_memory_input_stream_new_from_data =
      _g_memory_input_stream_new_from_dataPtr.asFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<ffi.Void>, int, GDestroyNotify)>();

  ffi.Pointer<GInputStream> g_memory_input_stream_new_from_bytes(
    ffi.Pointer<GBytes> bytes,
  ) {
    return _g_memory_input_stream_new_from_bytes(
      bytes,
    );
  }

  late final _g_memory_input_stream_new_from_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GBytes>)>>('g_memory_input_stream_new_from_bytes');
  late final _g_memory_input_stream_new_from_bytes =
      _g_memory_input_stream_new_from_bytesPtr.asFunction<
          ffi.Pointer<GInputStream> Function(ffi.Pointer<GBytes>)>();

  void g_memory_input_stream_add_data(
    ffi.Pointer<GMemoryInputStream> stream,
    ffi.Pointer<ffi.Void> data,
    int len,
    GDestroyNotify destroy,
  ) {
    return _g_memory_input_stream_add_data(
      stream,
      data,
      len,
      destroy,
    );
  }

  late final _g_memory_input_stream_add_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GMemoryInputStream>,
              ffi.Pointer<ffi.Void>,
              gssize,
              GDestroyNotify)>>('g_memory_input_stream_add_data');
  late final _g_memory_input_stream_add_data =
      _g_memory_input_stream_add_dataPtr.asFunction<
          void Function(ffi.Pointer<GMemoryInputStream>, ffi.Pointer<ffi.Void>,
              int, GDestroyNotify)>();

  void g_memory_input_stream_add_bytes(
    ffi.Pointer<GMemoryInputStream> stream,
    ffi.Pointer<GBytes> bytes,
  ) {
    return _g_memory_input_stream_add_bytes(
      stream,
      bytes,
    );
  }

  late final _g_memory_input_stream_add_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GMemoryInputStream>,
              ffi.Pointer<GBytes>)>>('g_memory_input_stream_add_bytes');
  late final _g_memory_input_stream_add_bytes =
      _g_memory_input_stream_add_bytesPtr.asFunction<
          void Function(
              ffi.Pointer<GMemoryInputStream>, ffi.Pointer<GBytes>)>();

  int g_memory_output_stream_get_type() {
    return _g_memory_output_stream_get_type();
  }

  late final _g_memory_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_memory_output_stream_get_type');
  late final _g_memory_output_stream_get_type =
      _g_memory_output_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GOutputStream> g_memory_output_stream_new(
    gpointer data,
    int size,
    GReallocFunc realloc_function,
    GDestroyNotify destroy_function,
  ) {
    return _g_memory_output_stream_new(
      data,
      size,
      realloc_function,
      destroy_function,
    );
  }

  late final _g_memory_output_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(gpointer, gsize, GReallocFunc,
              GDestroyNotify)>>('g_memory_output_stream_new');
  late final _g_memory_output_stream_new =
      _g_memory_output_stream_newPtr.asFunction<
          ffi.Pointer<GOutputStream> Function(
              gpointer, int, GReallocFunc, GDestroyNotify)>();

  ffi.Pointer<GOutputStream> g_memory_output_stream_new_resizable() {
    return _g_memory_output_stream_new_resizable();
  }

  late final _g_memory_output_stream_new_resizablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GOutputStream> Function()>>(
          'g_memory_output_stream_new_resizable');
  late final _g_memory_output_stream_new_resizable =
      _g_memory_output_stream_new_resizablePtr
          .asFunction<ffi.Pointer<GOutputStream> Function()>();

  gpointer g_memory_output_stream_get_data(
    ffi.Pointer<GMemoryOutputStream> ostream,
  ) {
    return _g_memory_output_stream_get_data(
      ostream,
    );
  }

  late final _g_memory_output_stream_get_dataPtr = _lookup<
          ffi
          .NativeFunction<gpointer Function(ffi.Pointer<GMemoryOutputStream>)>>(
      'g_memory_output_stream_get_data');
  late final _g_memory_output_stream_get_data =
      _g_memory_output_stream_get_dataPtr
          .asFunction<gpointer Function(ffi.Pointer<GMemoryOutputStream>)>();

  int g_memory_output_stream_get_size(
    ffi.Pointer<GMemoryOutputStream> ostream,
  ) {
    return _g_memory_output_stream_get_size(
      ostream,
    );
  }

  late final _g_memory_output_stream_get_sizePtr = _lookup<
          ffi.NativeFunction<gsize Function(ffi.Pointer<GMemoryOutputStream>)>>(
      'g_memory_output_stream_get_size');
  late final _g_memory_output_stream_get_size =
      _g_memory_output_stream_get_sizePtr
          .asFunction<int Function(ffi.Pointer<GMemoryOutputStream>)>();

  int g_memory_output_stream_get_data_size(
    ffi.Pointer<GMemoryOutputStream> ostream,
  ) {
    return _g_memory_output_stream_get_data_size(
      ostream,
    );
  }

  late final _g_memory_output_stream_get_data_sizePtr = _lookup<
          ffi.NativeFunction<gsize Function(ffi.Pointer<GMemoryOutputStream>)>>(
      'g_memory_output_stream_get_data_size');
  late final _g_memory_output_stream_get_data_size =
      _g_memory_output_stream_get_data_sizePtr
          .asFunction<int Function(ffi.Pointer<GMemoryOutputStream>)>();

  gpointer g_memory_output_stream_steal_data(
    ffi.Pointer<GMemoryOutputStream> ostream,
  ) {
    return _g_memory_output_stream_steal_data(
      ostream,
    );
  }

  late final _g_memory_output_stream_steal_dataPtr = _lookup<
          ffi
          .NativeFunction<gpointer Function(ffi.Pointer<GMemoryOutputStream>)>>(
      'g_memory_output_stream_steal_data');
  late final _g_memory_output_stream_steal_data =
      _g_memory_output_stream_steal_dataPtr
          .asFunction<gpointer Function(ffi.Pointer<GMemoryOutputStream>)>();

  ffi.Pointer<GBytes> g_memory_output_stream_steal_as_bytes(
    ffi.Pointer<GMemoryOutputStream> ostream,
  ) {
    return _g_memory_output_stream_steal_as_bytes(
      ostream,
    );
  }

  late final _g_memory_output_stream_steal_as_bytesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GBytes> Function(ffi.Pointer<GMemoryOutputStream>)>>(
      'g_memory_output_stream_steal_as_bytes');
  late final _g_memory_output_stream_steal_as_bytes =
      _g_memory_output_stream_steal_as_bytesPtr.asFunction<
          ffi.Pointer<GBytes> Function(ffi.Pointer<GMemoryOutputStream>)>();

  int g_pollable_input_stream_get_type() {
    return _g_pollable_input_stream_get_type();
  }

  late final _g_pollable_input_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_pollable_input_stream_get_type');
  late final _g_pollable_input_stream_get_type =
      _g_pollable_input_stream_get_typePtr.asFunction<int Function()>();

  int g_pollable_input_stream_can_poll(
    ffi.Pointer<GPollableInputStream> stream,
  ) {
    return _g_pollable_input_stream_can_poll(
      stream,
    );
  }

  late final _g_pollable_input_stream_can_pollPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream>)>>(
      'g_pollable_input_stream_can_poll');
  late final _g_pollable_input_stream_can_poll =
      _g_pollable_input_stream_can_pollPtr
          .asFunction<int Function(ffi.Pointer<GPollableInputStream>)>();

  int g_pollable_input_stream_is_readable(
    ffi.Pointer<GPollableInputStream> stream,
  ) {
    return _g_pollable_input_stream_is_readable(
      stream,
    );
  }

  late final _g_pollable_input_stream_is_readablePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream>)>>(
      'g_pollable_input_stream_is_readable');
  late final _g_pollable_input_stream_is_readable =
      _g_pollable_input_stream_is_readablePtr
          .asFunction<int Function(ffi.Pointer<GPollableInputStream>)>();

  ffi.Pointer<GSource$1> g_pollable_input_stream_create_source(
    ffi.Pointer<GPollableInputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
  ) {
    return _g_pollable_input_stream_create_source(
      stream,
      cancellable,
    );
  }

  late final _g_pollable_input_stream_create_sourcePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GSource$1> Function(ffi.Pointer<GPollableInputStream>,
                  ffi.Pointer<GCancellable>)>>(
      'g_pollable_input_stream_create_source');
  late final _g_pollable_input_stream_create_source =
      _g_pollable_input_stream_create_sourcePtr.asFunction<
          ffi.Pointer<GSource$1> Function(
              ffi.Pointer<GPollableInputStream>, ffi.Pointer<GCancellable>)>();

  int g_pollable_input_stream_read_nonblocking(
    ffi.Pointer<GPollableInputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_pollable_input_stream_read_nonblocking(
      stream,
      buffer,
      count,
      cancellable,
      error,
    );
  }

  late final _g_pollable_input_stream_read_nonblockingPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GPollableInputStream>,
                  ffi.Pointer<ffi.Void>,
                  gsize,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_pollable_input_stream_read_nonblocking');
  late final _g_pollable_input_stream_read_nonblocking =
      _g_pollable_input_stream_read_nonblockingPtr.asFunction<
          int Function(
              ffi.Pointer<GPollableInputStream>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_pollable_output_stream_get_type() {
    return _g_pollable_output_stream_get_type();
  }

  late final _g_pollable_output_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_pollable_output_stream_get_type');
  late final _g_pollable_output_stream_get_type =
      _g_pollable_output_stream_get_typePtr.asFunction<int Function()>();

  int g_pollable_output_stream_can_poll(
    ffi.Pointer<GPollableOutputStream> stream,
  ) {
    return _g_pollable_output_stream_can_poll(
      stream,
    );
  }

  late final _g_pollable_output_stream_can_pollPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream>)>>(
      'g_pollable_output_stream_can_poll');
  late final _g_pollable_output_stream_can_poll =
      _g_pollable_output_stream_can_pollPtr
          .asFunction<int Function(ffi.Pointer<GPollableOutputStream>)>();

  int g_pollable_output_stream_is_writable(
    ffi.Pointer<GPollableOutputStream> stream,
  ) {
    return _g_pollable_output_stream_is_writable(
      stream,
    );
  }

  late final _g_pollable_output_stream_is_writablePtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream>)>>(
      'g_pollable_output_stream_is_writable');
  late final _g_pollable_output_stream_is_writable =
      _g_pollable_output_stream_is_writablePtr
          .asFunction<int Function(ffi.Pointer<GPollableOutputStream>)>();

  ffi.Pointer<GSource$1> g_pollable_output_stream_create_source(
    ffi.Pointer<GPollableOutputStream> stream,
    ffi.Pointer<GCancellable> cancellable,
  ) {
    return _g_pollable_output_stream_create_source(
      stream,
      cancellable,
    );
  }

  late final _g_pollable_output_stream_create_sourcePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<GSource$1> Function(
                  ffi.Pointer<GPollableOutputStream>,
                  ffi.Pointer<GCancellable>)>>(
      'g_pollable_output_stream_create_source');
  late final _g_pollable_output_stream_create_source =
      _g_pollable_output_stream_create_sourcePtr.asFunction<
          ffi.Pointer<GSource$1> Function(
              ffi.Pointer<GPollableOutputStream>, ffi.Pointer<GCancellable>)>();

  int g_pollable_output_stream_write_nonblocking(
    ffi.Pointer<GPollableOutputStream> stream,
    ffi.Pointer<ffi.Void> buffer,
    int count,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _g_pollable_output_stream_write_nonblocking(
      stream,
      buffer,
      count,
      cancellable,
      error,
    );
  }

  late final _g_pollable_output_stream_write_nonblockingPtr = _lookup<
          ffi.NativeFunction<
              gssize Function(
                  ffi.Pointer<GPollableOutputStream>,
                  ffi.Pointer<ffi.Void>,
                  gsize,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_pollable_output_stream_write_nonblocking');
  late final _g_pollable_output_stream_write_nonblocking =
      _g_pollable_output_stream_write_nonblockingPtr.asFunction<
          int Function(
              ffi.Pointer<GPollableOutputStream>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  GPollableReturn g_pollable_output_stream_writev_nonblocking(
    ffi.Pointer<GPollableOutputStream> stream,
    ffi.Pointer<GOutputVector> vectors,
    Dartgsize n_vectors,
    ffi.Pointer<gsize> bytes_written,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return GPollableReturn.fromValue(
        _g_pollable_output_stream_writev_nonblocking(
      stream,
      vectors,
      n_vectors,
      bytes_written,
      cancellable,
      error,
    ));
  }

  late final _g_pollable_output_stream_writev_nonblockingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<GPollableOutputStream>,
                  ffi.Pointer<GOutputVector>,
                  gsize,
                  ffi.Pointer<gsize>,
                  ffi.Pointer<GCancellable>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_pollable_output_stream_writev_nonblocking');
  late final _g_pollable_output_stream_writev_nonblocking =
      _g_pollable_output_stream_writev_nonblockingPtr.asFunction<
          int Function(
              ffi.Pointer<GPollableOutputStream>,
              ffi.Pointer<GOutputVector>,
              int,
              ffi.Pointer<gsize>,
              ffi.Pointer<GCancellable>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  int g_simple_async_result_get_type() {
    return _g_simple_async_result_get_type();
  }

  late final _g_simple_async_result_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_simple_async_result_get_type');
  late final _g_simple_async_result_get_type =
      _g_simple_async_result_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GSimpleAsyncResult> g_simple_async_result_new(
    ffi.Pointer<GObject> source_object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    gpointer source_tag,
  ) {
    return _g_simple_async_result_new(
      source_object,
      callback,
      user_data,
      source_tag,
    );
  }

  late final _g_simple_async_result_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              gpointer)>>('g_simple_async_result_new');
  late final _g_simple_async_result_new =
      _g_simple_async_result_newPtr.asFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>, GAsyncReadyCallback, gpointer, gpointer)>();

  ffi.Pointer<GSimpleAsyncResult> g_simple_async_result_new_error(
    ffi.Pointer<GObject> source_object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    int domain,
    int code,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _g_simple_async_result_new_error(
      source_object,
      callback,
      user_data,
      domain,
      code,
      format,
    );
  }

  late final _g_simple_async_result_new_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              GQuark,
              gint,
              ffi.Pointer<ffi.Char>)>>('g_simple_async_result_new_error');
  late final _g_simple_async_result_new_error =
      _g_simple_async_result_new_errorPtr.asFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              int,
              int,
              ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<GSimpleAsyncResult> g_simple_async_result_new_from_error(
    ffi.Pointer<GObject> source_object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_result_new_from_error(
      source_object,
      callback,
      user_data,
      error,
    );
  }

  late final _g_simple_async_result_new_from_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              ffi.Pointer<GError>)>>('g_simple_async_result_new_from_error');
  late final _g_simple_async_result_new_from_error =
      _g_simple_async_result_new_from_errorPtr.asFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(ffi.Pointer<GObject>,
              GAsyncReadyCallback, gpointer, ffi.Pointer<GError>)>();

  ffi.Pointer<GSimpleAsyncResult> g_simple_async_result_new_take_error(
    ffi.Pointer<GObject> source_object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_result_new_take_error(
      source_object,
      callback,
      user_data,
      error,
    );
  }

  late final _g_simple_async_result_new_take_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              ffi.Pointer<GError>)>>('g_simple_async_result_new_take_error');
  late final _g_simple_async_result_new_take_error =
      _g_simple_async_result_new_take_errorPtr.asFunction<
          ffi.Pointer<GSimpleAsyncResult> Function(ffi.Pointer<GObject>,
              GAsyncReadyCallback, gpointer, ffi.Pointer<GError>)>();

  void g_simple_async_result_set_op_res_gpointer(
    ffi.Pointer<GSimpleAsyncResult> simple,
    gpointer op_res,
    GDestroyNotify destroy_op_res,
  ) {
    return _g_simple_async_result_set_op_res_gpointer(
      simple,
      op_res,
      destroy_op_res,
    );
  }

  late final _g_simple_async_result_set_op_res_gpointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>, gpointer,
              GDestroyNotify)>>('g_simple_async_result_set_op_res_gpointer');
  late final _g_simple_async_result_set_op_res_gpointer =
      _g_simple_async_result_set_op_res_gpointerPtr.asFunction<
          void Function(
              ffi.Pointer<GSimpleAsyncResult>, gpointer, GDestroyNotify)>();

  gpointer g_simple_async_result_get_op_res_gpointer(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_get_op_res_gpointer(
      simple,
    );
  }

  late final _g_simple_async_result_get_op_res_gpointerPtr = _lookup<
          ffi
          .NativeFunction<gpointer Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_get_op_res_gpointer');
  late final _g_simple_async_result_get_op_res_gpointer =
      _g_simple_async_result_get_op_res_gpointerPtr
          .asFunction<gpointer Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_set_op_res_gssize(
    ffi.Pointer<GSimpleAsyncResult> simple,
    int op_res,
  ) {
    return _g_simple_async_result_set_op_res_gssize(
      simple,
      op_res,
    );
  }

  late final _g_simple_async_result_set_op_res_gssizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
              gssize)>>('g_simple_async_result_set_op_res_gssize');
  late final _g_simple_async_result_set_op_res_gssize =
      _g_simple_async_result_set_op_res_gssizePtr
          .asFunction<void Function(ffi.Pointer<GSimpleAsyncResult>, int)>();

  int g_simple_async_result_get_op_res_gssize(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_get_op_res_gssize(
      simple,
    );
  }

  late final _g_simple_async_result_get_op_res_gssizePtr = _lookup<
          ffi.NativeFunction<gssize Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_get_op_res_gssize');
  late final _g_simple_async_result_get_op_res_gssize =
      _g_simple_async_result_get_op_res_gssizePtr
          .asFunction<int Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_set_op_res_gboolean(
    ffi.Pointer<GSimpleAsyncResult> simple,
    int op_res,
  ) {
    return _g_simple_async_result_set_op_res_gboolean(
      simple,
      op_res,
    );
  }

  late final _g_simple_async_result_set_op_res_gbooleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
              gboolean)>>('g_simple_async_result_set_op_res_gboolean');
  late final _g_simple_async_result_set_op_res_gboolean =
      _g_simple_async_result_set_op_res_gbooleanPtr
          .asFunction<void Function(ffi.Pointer<GSimpleAsyncResult>, int)>();

  int g_simple_async_result_get_op_res_gboolean(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_get_op_res_gboolean(
      simple,
    );
  }

  late final _g_simple_async_result_get_op_res_gbooleanPtr = _lookup<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_get_op_res_gboolean');
  late final _g_simple_async_result_get_op_res_gboolean =
      _g_simple_async_result_get_op_res_gbooleanPtr
          .asFunction<int Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_set_check_cancellable(
    ffi.Pointer<GSimpleAsyncResult> simple,
    ffi.Pointer<GCancellable> check_cancellable,
  ) {
    return _g_simple_async_result_set_check_cancellable(
      simple,
      check_cancellable,
    );
  }

  late final _g_simple_async_result_set_check_cancellablePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GSimpleAsyncResult>, ffi.Pointer<GCancellable>)>>(
      'g_simple_async_result_set_check_cancellable');
  late final _g_simple_async_result_set_check_cancellable =
      _g_simple_async_result_set_check_cancellablePtr.asFunction<
          void Function(
              ffi.Pointer<GSimpleAsyncResult>, ffi.Pointer<GCancellable>)>();

  gpointer g_simple_async_result_get_source_tag(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_get_source_tag(
      simple,
    );
  }

  late final _g_simple_async_result_get_source_tagPtr = _lookup<
          ffi
          .NativeFunction<gpointer Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_get_source_tag');
  late final _g_simple_async_result_get_source_tag =
      _g_simple_async_result_get_source_tagPtr
          .asFunction<gpointer Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_set_handle_cancellation(
    ffi.Pointer<GSimpleAsyncResult> simple,
    int handle_cancellation,
  ) {
    return _g_simple_async_result_set_handle_cancellation(
      simple,
      handle_cancellation,
    );
  }

  late final _g_simple_async_result_set_handle_cancellationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
              gboolean)>>('g_simple_async_result_set_handle_cancellation');
  late final _g_simple_async_result_set_handle_cancellation =
      _g_simple_async_result_set_handle_cancellationPtr
          .asFunction<void Function(ffi.Pointer<GSimpleAsyncResult>, int)>();

  void g_simple_async_result_complete(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_complete(
      simple,
    );
  }

  late final _g_simple_async_result_completePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_complete');
  late final _g_simple_async_result_complete =
      _g_simple_async_result_completePtr
          .asFunction<void Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_complete_in_idle(
    ffi.Pointer<GSimpleAsyncResult> simple,
  ) {
    return _g_simple_async_result_complete_in_idle(
      simple,
    );
  }

  late final _g_simple_async_result_complete_in_idlePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>)>>(
      'g_simple_async_result_complete_in_idle');
  late final _g_simple_async_result_complete_in_idle =
      _g_simple_async_result_complete_in_idlePtr
          .asFunction<void Function(ffi.Pointer<GSimpleAsyncResult>)>();

  void g_simple_async_result_run_in_thread(
    ffi.Pointer<GSimpleAsyncResult> simple,
    GSimpleAsyncThreadFunc func,
    int io_priority,
    ffi.Pointer<GCancellable> cancellable,
  ) {
    return _g_simple_async_result_run_in_thread(
      simple,
      func,
      io_priority,
      cancellable,
    );
  }

  late final _g_simple_async_result_run_in_threadPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
                  GSimpleAsyncThreadFunc, ffi.Int, ffi.Pointer<GCancellable>)>>(
      'g_simple_async_result_run_in_thread');
  late final _g_simple_async_result_run_in_thread =
      _g_simple_async_result_run_in_threadPtr.asFunction<
          void Function(ffi.Pointer<GSimpleAsyncResult>, GSimpleAsyncThreadFunc,
              int, ffi.Pointer<GCancellable>)>();

  void g_simple_async_result_set_from_error(
    ffi.Pointer<GSimpleAsyncResult> simple,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_result_set_from_error(
      simple,
      error,
    );
  }

  late final _g_simple_async_result_set_from_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
              ffi.Pointer<GError>)>>('g_simple_async_result_set_from_error');
  late final _g_simple_async_result_set_from_error =
      _g_simple_async_result_set_from_errorPtr.asFunction<
          void Function(
              ffi.Pointer<GSimpleAsyncResult>, ffi.Pointer<GError>)>();

  void g_simple_async_result_take_error(
    ffi.Pointer<GSimpleAsyncResult> simple,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_result_take_error(
      simple,
      error,
    );
  }

  late final _g_simple_async_result_take_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>,
              ffi.Pointer<GError>)>>('g_simple_async_result_take_error');
  late final _g_simple_async_result_take_error =
      _g_simple_async_result_take_errorPtr.asFunction<
          void Function(
              ffi.Pointer<GSimpleAsyncResult>, ffi.Pointer<GError>)>();

  int g_simple_async_result_propagate_error(
    ffi.Pointer<GSimpleAsyncResult> simple,
    ffi.Pointer<ffi.Pointer<GError>> dest,
  ) {
    return _g_simple_async_result_propagate_error(
      simple,
      dest,
    );
  }

  late final _g_simple_async_result_propagate_errorPtr = _lookup<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GSimpleAsyncResult>,
                  ffi.Pointer<ffi.Pointer<GError>>)>>(
      'g_simple_async_result_propagate_error');
  late final _g_simple_async_result_propagate_error =
      _g_simple_async_result_propagate_errorPtr.asFunction<
          int Function(ffi.Pointer<GSimpleAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>();

  void g_simple_async_result_set_error(
    ffi.Pointer<GSimpleAsyncResult> simple,
    int domain,
    int code,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _g_simple_async_result_set_error(
      simple,
      domain,
      code,
      format,
    );
  }

  late final _g_simple_async_result_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>, GQuark, gint,
              ffi.Pointer<ffi.Char>)>>('g_simple_async_result_set_error');
  late final _g_simple_async_result_set_error =
      _g_simple_async_result_set_errorPtr.asFunction<
          void Function(ffi.Pointer<GSimpleAsyncResult>, int, int,
              ffi.Pointer<ffi.Char>)>();

  void g_simple_async_result_set_error_va(
    ffi.Pointer<GSimpleAsyncResult> simple,
    int domain,
    int code,
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _g_simple_async_result_set_error_va(
      simple,
      domain,
      code,
      format,
      args,
    );
  }

  late final _g_simple_async_result_set_error_vaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GSimpleAsyncResult>, GQuark, gint,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>(
      'g_simple_async_result_set_error_va');
  late final _g_simple_async_result_set_error_va =
      _g_simple_async_result_set_error_vaPtr.asFunction<
          void Function(ffi.Pointer<GSimpleAsyncResult>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int g_simple_async_result_is_valid(
    ffi.Pointer<GAsyncResult> result,
    ffi.Pointer<GObject> source,
    gpointer source_tag,
  ) {
    return _g_simple_async_result_is_valid(
      result,
      source,
      source_tag,
    );
  }

  late final _g_simple_async_result_is_validPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GAsyncResult>, ffi.Pointer<GObject>,
              gpointer)>>('g_simple_async_result_is_valid');
  late final _g_simple_async_result_is_valid =
      _g_simple_async_result_is_validPtr.asFunction<
          int Function(
              ffi.Pointer<GAsyncResult>, ffi.Pointer<GObject>, gpointer)>();

  void g_simple_async_report_error_in_idle(
    ffi.Pointer<GObject> object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    int domain,
    int code,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _g_simple_async_report_error_in_idle(
      object,
      callback,
      user_data,
      domain,
      code,
      format,
    );
  }

  late final _g_simple_async_report_error_in_idlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GObject>,
              GAsyncReadyCallback,
              gpointer,
              GQuark,
              gint,
              ffi.Pointer<ffi.Char>)>>('g_simple_async_report_error_in_idle');
  late final _g_simple_async_report_error_in_idle =
      _g_simple_async_report_error_in_idlePtr.asFunction<
          void Function(ffi.Pointer<GObject>, GAsyncReadyCallback, gpointer,
              int, int, ffi.Pointer<ffi.Char>)>();

  void g_simple_async_report_gerror_in_idle(
    ffi.Pointer<GObject> object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_report_gerror_in_idle(
      object,
      callback,
      user_data,
      error,
    );
  }

  late final _g_simple_async_report_gerror_in_idlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GObject>, GAsyncReadyCallback, gpointer,
              ffi.Pointer<GError>)>>('g_simple_async_report_gerror_in_idle');
  late final _g_simple_async_report_gerror_in_idle =
      _g_simple_async_report_gerror_in_idlePtr.asFunction<
          void Function(ffi.Pointer<GObject>, GAsyncReadyCallback, gpointer,
              ffi.Pointer<GError>)>();

  void g_simple_async_report_take_gerror_in_idle(
    ffi.Pointer<GObject> object,
    GAsyncReadyCallback callback,
    gpointer user_data,
    ffi.Pointer<GError> error,
  ) {
    return _g_simple_async_report_take_gerror_in_idle(
      object,
      callback,
      user_data,
      error,
    );
  }

  late final _g_simple_async_report_take_gerror_in_idlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GObject>, GAsyncReadyCallback,
                  gpointer, ffi.Pointer<GError>)>>(
      'g_simple_async_report_take_gerror_in_idle');
  late final _g_simple_async_report_take_gerror_in_idle =
      _g_simple_async_report_take_gerror_in_idlePtr.asFunction<
          void Function(ffi.Pointer<GObject>, GAsyncReadyCallback, gpointer,
              ffi.Pointer<GError>)>();

  int g_simple_io_stream_get_type() {
    return _g_simple_io_stream_get_type();
  }

  late final _g_simple_io_stream_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>(
          'g_simple_io_stream_get_type');
  late final _g_simple_io_stream_get_type =
      _g_simple_io_stream_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<GIOStream> g_simple_io_stream_new(
    ffi.Pointer<GInputStream> input_stream,
    ffi.Pointer<GOutputStream> output_stream,
  ) {
    return _g_simple_io_stream_new(
      input_stream,
      output_stream,
    );
  }

  late final _g_simple_io_stream_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GIOStream> Function(ffi.Pointer<GInputStream>,
              ffi.Pointer<GOutputStream>)>>('g_simple_io_stream_new');
  late final _g_simple_io_stream_new = _g_simple_io_stream_newPtr.asFunction<
      ffi.Pointer<GIOStream> Function(
          ffi.Pointer<GInputStream>, ffi.Pointer<GOutputStream>)>();

  int wp_core_get_type() {
    return _wp_core_get_type();
  }

  late final _wp_core_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('wp_core_get_type');
  late final _wp_core_get_type =
      _wp_core_get_typePtr.asFunction<int Function()>();

  ffi.Pointer<WpCore> wp_core_new(
    ffi.Pointer<GMainContext> context,
    ffi.Pointer<WpProperties> properties,
  ) {
    return _wp_core_new(
      context,
      properties,
    );
  }

  late final _wp_core_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpCore> Function(ffi.Pointer<GMainContext>,
              ffi.Pointer<WpProperties>)>>('wp_core_new');
  late final _wp_core_new = _wp_core_newPtr.asFunction<
      ffi.Pointer<WpCore> Function(
          ffi.Pointer<GMainContext>, ffi.Pointer<WpProperties>)>();

  ffi.Pointer<WpCore> wp_core_clone(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_clone(
      self,
    );
  }

  late final _wp_core_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpCore> Function(ffi.Pointer<WpCore>)>>('wp_core_clone');
  late final _wp_core_clone = _wp_core_clonePtr
      .asFunction<ffi.Pointer<WpCore> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<GMainContext> wp_core_get_g_main_context(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_g_main_context(
      self,
    );
  }

  late final _wp_core_get_g_main_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GMainContext> Function(
              ffi.Pointer<WpCore>)>>('wp_core_get_g_main_context');
  late final _wp_core_get_g_main_context = _wp_core_get_g_main_contextPtr
      .asFunction<ffi.Pointer<GMainContext> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<pw_context> wp_core_get_pw_context(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_pw_context(
      self,
    );
  }

  late final _wp_core_get_pw_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pw_context> Function(
              ffi.Pointer<WpCore>)>>('wp_core_get_pw_context');
  late final _wp_core_get_pw_context = _wp_core_get_pw_contextPtr
      .asFunction<ffi.Pointer<pw_context> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<pw_core> wp_core_get_pw_core(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_pw_core(
      self,
    );
  }

  late final _wp_core_get_pw_corePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<pw_core> Function(ffi.Pointer<WpCore>)>>(
      'wp_core_get_pw_core');
  late final _wp_core_get_pw_core = _wp_core_get_pw_corePtr
      .asFunction<ffi.Pointer<pw_core> Function(ffi.Pointer<WpCore>)>();

  int wp_core_load_component(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<gchar> component,
    ffi.Pointer<gchar> type,
    ffi.Pointer<GVariant> args,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _wp_core_load_component(
      self,
      component,
      type,
      args,
      error,
    );
  }

  late final _wp_core_load_componentPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<gchar>,
              ffi.Pointer<gchar>,
              ffi.Pointer<GVariant>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('wp_core_load_component');
  late final _wp_core_load_component = _wp_core_load_componentPtr.asFunction<
      int Function(ffi.Pointer<WpCore>, ffi.Pointer<gchar>, ffi.Pointer<gchar>,
          ffi.Pointer<GVariant>, ffi.Pointer<ffi.Pointer<GError>>)>();

  int wp_core_connect(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_connect(
      self,
    );
  }

  late final _wp_core_connectPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<WpCore>)>>(
          'wp_core_connect');
  late final _wp_core_connect =
      _wp_core_connectPtr.asFunction<int Function(ffi.Pointer<WpCore>)>();

  void wp_core_disconnect(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_disconnect(
      self,
    );
  }

  late final _wp_core_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WpCore>)>>(
          'wp_core_disconnect');
  late final _wp_core_disconnect =
      _wp_core_disconnectPtr.asFunction<void Function(ffi.Pointer<WpCore>)>();

  int wp_core_is_connected(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_is_connected(
      self,
    );
  }

  late final _wp_core_is_connectedPtr =
      _lookup<ffi.NativeFunction<gboolean Function(ffi.Pointer<WpCore>)>>(
          'wp_core_is_connected');
  late final _wp_core_is_connected =
      _wp_core_is_connectedPtr.asFunction<int Function(ffi.Pointer<WpCore>)>();

  int wp_core_get_remote_cookie(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_cookie(
      self,
    );
  }

  late final _wp_core_get_remote_cookiePtr =
      _lookup<ffi.NativeFunction<guint32 Function(ffi.Pointer<WpCore>)>>(
          'wp_core_get_remote_cookie');
  late final _wp_core_get_remote_cookie = _wp_core_get_remote_cookiePtr
      .asFunction<int Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<gchar> wp_core_get_remote_name(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_name(
      self,
    );
  }

  late final _wp_core_get_remote_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>>(
      'wp_core_get_remote_name');
  late final _wp_core_get_remote_name = _wp_core_get_remote_namePtr
      .asFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<gchar> wp_core_get_remote_user_name(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_user_name(
      self,
    );
  }

  late final _wp_core_get_remote_user_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>>(
      'wp_core_get_remote_user_name');
  late final _wp_core_get_remote_user_name = _wp_core_get_remote_user_namePtr
      .asFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<gchar> wp_core_get_remote_host_name(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_host_name(
      self,
    );
  }

  late final _wp_core_get_remote_host_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>>(
      'wp_core_get_remote_host_name');
  late final _wp_core_get_remote_host_name = _wp_core_get_remote_host_namePtr
      .asFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<gchar> wp_core_get_remote_version(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_version(
      self,
    );
  }

  late final _wp_core_get_remote_versionPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>>(
      'wp_core_get_remote_version');
  late final _wp_core_get_remote_version = _wp_core_get_remote_versionPtr
      .asFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<WpProperties> wp_core_get_remote_properties(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_remote_properties(
      self,
    );
  }

  late final _wp_core_get_remote_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpProperties> Function(
              ffi.Pointer<WpCore>)>>('wp_core_get_remote_properties');
  late final _wp_core_get_remote_properties = _wp_core_get_remote_propertiesPtr
      .asFunction<ffi.Pointer<WpProperties> Function(ffi.Pointer<WpCore>)>();

  ffi.Pointer<WpProperties> wp_core_get_properties(
    ffi.Pointer<WpCore> self,
  ) {
    return _wp_core_get_properties(
      self,
    );
  }

  late final _wp_core_get_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpProperties> Function(
              ffi.Pointer<WpCore>)>>('wp_core_get_properties');
  late final _wp_core_get_properties = _wp_core_get_propertiesPtr
      .asFunction<ffi.Pointer<WpProperties> Function(ffi.Pointer<WpCore>)>();

  void wp_core_update_properties(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<WpProperties> updates,
  ) {
    return _wp_core_update_properties(
      self,
      updates,
    );
  }

  late final _wp_core_update_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<WpCore>,
              ffi.Pointer<WpProperties>)>>('wp_core_update_properties');
  late final _wp_core_update_properties =
      _wp_core_update_propertiesPtr.asFunction<
          void Function(ffi.Pointer<WpCore>, ffi.Pointer<WpProperties>)>();

  void wp_core_idle_add(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<ffi.Pointer<GSource$1>> source,
    GSourceFunc function,
    gpointer data,
    GDestroyNotify destroy,
  ) {
    return _wp_core_idle_add(
      self,
      source,
      function,
      data,
      destroy,
    );
  }

  late final _wp_core_idle_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>,
              GSourceFunc,
              gpointer,
              GDestroyNotify)>>('wp_core_idle_add');
  late final _wp_core_idle_add = _wp_core_idle_addPtr.asFunction<
      void Function(ffi.Pointer<WpCore>, ffi.Pointer<ffi.Pointer<GSource$1>>,
          GSourceFunc, gpointer, GDestroyNotify)>();

  void wp_core_idle_add_closure(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<ffi.Pointer<GSource$1>> source,
    ffi.Pointer<GClosure> closure,
  ) {
    return _wp_core_idle_add_closure(
      self,
      source,
      closure,
    );
  }

  late final _wp_core_idle_add_closurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>,
              ffi.Pointer<GClosure>)>>('wp_core_idle_add_closure');
  late final _wp_core_idle_add_closure =
      _wp_core_idle_add_closurePtr.asFunction<
          void Function(ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>, ffi.Pointer<GClosure>)>();

  void wp_core_timeout_add(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<ffi.Pointer<GSource$1>> source,
    int timeout_ms,
    GSourceFunc function,
    gpointer data,
    GDestroyNotify destroy,
  ) {
    return _wp_core_timeout_add(
      self,
      source,
      timeout_ms,
      function,
      data,
      destroy,
    );
  }

  late final _wp_core_timeout_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>,
              guint,
              GSourceFunc,
              gpointer,
              GDestroyNotify)>>('wp_core_timeout_add');
  late final _wp_core_timeout_add = _wp_core_timeout_addPtr.asFunction<
      void Function(ffi.Pointer<WpCore>, ffi.Pointer<ffi.Pointer<GSource$1>>,
          int, GSourceFunc, gpointer, GDestroyNotify)>();

  void wp_core_timeout_add_closure(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<ffi.Pointer<GSource$1>> source,
    int timeout_ms,
    ffi.Pointer<GClosure> closure,
  ) {
    return _wp_core_timeout_add_closure(
      self,
      source,
      timeout_ms,
      closure,
    );
  }

  late final _wp_core_timeout_add_closurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>,
              guint,
              ffi.Pointer<GClosure>)>>('wp_core_timeout_add_closure');
  late final _wp_core_timeout_add_closure =
      _wp_core_timeout_add_closurePtr.asFunction<
          void Function(
              ffi.Pointer<WpCore>,
              ffi.Pointer<ffi.Pointer<GSource$1>>,
              int,
              ffi.Pointer<GClosure>)>();

  int wp_core_sync(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<GCancellable> cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data,
  ) {
    return _wp_core_sync(
      self,
      cancellable,
      callback,
      user_data,
    );
  }

  late final _wp_core_syncPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<WpCore>, ffi.Pointer<GCancellable>,
              GAsyncReadyCallback, gpointer)>>('wp_core_sync');
  late final _wp_core_sync = _wp_core_syncPtr.asFunction<
      int Function(ffi.Pointer<WpCore>, ffi.Pointer<GCancellable>,
          GAsyncReadyCallback, gpointer)>();

  int wp_core_sync_closure(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<GCancellable> cancellable,
    ffi.Pointer<GClosure> closure,
  ) {
    return _wp_core_sync_closure(
      self,
      cancellable,
      closure,
    );
  }

  late final _wp_core_sync_closurePtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<WpCore>, ffi.Pointer<GCancellable>,
              ffi.Pointer<GClosure>)>>('wp_core_sync_closure');
  late final _wp_core_sync_closure = _wp_core_sync_closurePtr.asFunction<
      int Function(ffi.Pointer<WpCore>, ffi.Pointer<GCancellable>,
          ffi.Pointer<GClosure>)>();

  int wp_core_sync_finish(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<GAsyncResult> res,
    ffi.Pointer<ffi.Pointer<GError>> error,
  ) {
    return _wp_core_sync_finish(
      self,
      res,
      error,
    );
  }

  late final _wp_core_sync_finishPtr = _lookup<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<WpCore>, ffi.Pointer<GAsyncResult>,
              ffi.Pointer<ffi.Pointer<GError>>)>>('wp_core_sync_finish');
  late final _wp_core_sync_finish = _wp_core_sync_finishPtr.asFunction<
      int Function(ffi.Pointer<WpCore>, ffi.Pointer<GAsyncResult>,
          ffi.Pointer<ffi.Pointer<GError>>)>();

  void wp_core_install_object_manager(
    ffi.Pointer<WpCore> self,
    ffi.Pointer<WpObjectManager> om,
  ) {
    return _wp_core_install_object_manager(
      self,
      om,
    );
  }

  late final _wp_core_install_object_managerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<WpCore>,
              ffi.Pointer<WpObjectManager>)>>('wp_core_install_object_manager');
  late final _wp_core_install_object_manager =
      _wp_core_install_object_managerPtr.asFunction<
          void Function(ffi.Pointer<WpCore>, ffi.Pointer<WpObjectManager>)>();

  int wp_plugin_get_type() {
    return _wp_plugin_get_type();
  }

  late final _wp_plugin_get_typePtr =
      _lookup<ffi.NativeFunction<GType Function()>>('wp_plugin_get_type');
  late final _wp_plugin_get_type =
      _wp_plugin_get_typePtr.asFunction<int Function()>();

  void wp_plugin_register(
    ffi.Pointer<WpPlugin> plugin,
  ) {
    return _wp_plugin_register(
      plugin,
    );
  }

  late final _wp_plugin_registerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WpPlugin>)>>(
          'wp_plugin_register');
  late final _wp_plugin_register =
      _wp_plugin_registerPtr.asFunction<void Function(ffi.Pointer<WpPlugin>)>();

  ffi.Pointer<WpPlugin> wp_plugin_find(
    ffi.Pointer<WpCore> core,
    ffi.Pointer<gchar> plugin_name,
  ) {
    return _wp_plugin_find(
      core,
      plugin_name,
    );
  }

  late final _wp_plugin_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpPlugin> Function(
              ffi.Pointer<WpCore>, ffi.Pointer<gchar>)>>('wp_plugin_find');
  late final _wp_plugin_find = _wp_plugin_findPtr.asFunction<
      ffi.Pointer<WpPlugin> Function(
          ffi.Pointer<WpCore>, ffi.Pointer<gchar>)>();

  ffi.Pointer<gchar> wp_plugin_get_name(
    ffi.Pointer<WpPlugin> self,
  ) {
    return _wp_plugin_get_name(
      self,
    );
  }

  late final _wp_plugin_get_namePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpPlugin>)>>(
      'wp_plugin_get_name');
  late final _wp_plugin_get_name = _wp_plugin_get_namePtr
      .asFunction<ffi.Pointer<gchar> Function(ffi.Pointer<WpPlugin>)>();

  void wp_init(
    WpInitFlags flags,
  ) {
    return _wp_init(
      flags.value,
    );
  }

  late final _wp_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'wp_init');
  late final _wp_init = _wp_initPtr.asFunction<void Function(int)>();

  ffi.Pointer<gchar> wp_get_module_dir() {
    return _wp_get_module_dir();
  }

  late final _wp_get_module_dirPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<gchar> Function()>>(
          'wp_get_module_dir');
  late final _wp_get_module_dir =
      _wp_get_module_dirPtr.asFunction<ffi.Pointer<gchar> Function()>();

  ffi.Pointer<gchar> wp_get_config_dir() {
    return _wp_get_config_dir();
  }

  late final _wp_get_config_dirPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<gchar> Function()>>(
          'wp_get_config_dir');
  late final _wp_get_config_dir =
      _wp_get_config_dirPtr.asFunction<ffi.Pointer<gchar> Function()>();

  ffi.Pointer<gchar> wp_get_data_dir() {
    return _wp_get_data_dir();
  }

  late final _wp_get_data_dirPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<gchar> Function()>>(
          'wp_get_data_dir');
  late final _wp_get_data_dir =
      _wp_get_data_dirPtr.asFunction<ffi.Pointer<gchar> Function()>();

  ffi.Pointer<gchar> wp_find_file(
    WpLookupDirs dirs,
    ffi.Pointer<gchar> filename,
    ffi.Pointer<ffi.Char> subdir,
  ) {
    return _wp_find_file(
      dirs.value,
      filename,
      subdir,
    );
  }

  late final _wp_find_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(ffi.UnsignedInt, ffi.Pointer<gchar>,
              ffi.Pointer<ffi.Char>)>>('wp_find_file');
  late final _wp_find_file = _wp_find_filePtr.asFunction<
      ffi.Pointer<gchar> Function(
          int, ffi.Pointer<gchar>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<WpIterator> wp_new_files_iterator(
    WpLookupDirs dirs,
    ffi.Pointer<gchar> subdir,
    ffi.Pointer<gchar> suffix,
  ) {
    return _wp_new_files_iterator(
      dirs.value,
      subdir,
      suffix,
    );
  }

  late final _wp_new_files_iteratorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WpIterator> Function(ffi.UnsignedInt, ffi.Pointer<gchar>,
              ffi.Pointer<gchar>)>>('wp_new_files_iterator');
  late final _wp_new_files_iterator = _wp_new_files_iteratorPtr.asFunction<
      ffi.Pointer<WpIterator> Function(
          int, ffi.Pointer<gchar>, ffi.Pointer<gchar>)>();
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __uint64_t = ffi.UnsignedLong;
typedef Dart__uint64_t = int;

final class _fpx_sw_bytes extends ffi.Struct {
  @__uint32_t()
  external int magic1;

  @__uint32_t()
  external int extended_size;

  @__uint64_t()
  external int xstate_bv;

  @__uint32_t()
  external int xstate_size;

  @ffi.Array.multi([7])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

final class _fpreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;
}

final class _fpxreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __glibc_reserved1;
}

final class _xmmreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__uint32_t> element;
}

typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;

final class _fpstate extends ffi.Struct {
  @__uint16_t()
  external int cwd;

  @__uint16_t()
  external int swd;

  @__uint16_t()
  external int ftw;

  @__uint16_t()
  external int fop;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int rdp;

  @__uint32_t()
  external int mxcsr;

  @__uint32_t()
  external int mxcr_mask;

  @ffi.Array.multi([8])
  external ffi.Array<_fpxreg> _st;

  @ffi.Array.multi([16])
  external ffi.Array<_xmmreg> _xmm;

  @ffi.Array.multi([24])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

final class UnnamedUnion1 extends ffi.Union {
  external ffi.Pointer<_fpstate> fpstate;

  @__uint64_t()
  external int __fpstate_word;
}

final class sigcontext extends ffi.Struct {
  @__uint64_t()
  external int r8;

  @__uint64_t()
  external int r9;

  @__uint64_t()
  external int r10;

  @__uint64_t()
  external int r11;

  @__uint64_t()
  external int r12;

  @__uint64_t()
  external int r13;

  @__uint64_t()
  external int r14;

  @__uint64_t()
  external int r15;

  @__uint64_t()
  external int rdi;

  @__uint64_t()
  external int rsi;

  @__uint64_t()
  external int rbp;

  @__uint64_t()
  external int rbx;

  @__uint64_t()
  external int rdx;

  @__uint64_t()
  external int rax;

  @__uint64_t()
  external int rcx;

  @__uint64_t()
  external int rsp;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int eflags;

  @ffi.UnsignedShort()
  external int cs;

  @ffi.UnsignedShort()
  external int gs;

  @ffi.UnsignedShort()
  external int fs;

  @ffi.UnsignedShort()
  external int __pad0;

  @__uint64_t()
  external int err;

  @__uint64_t()
  external int trapno;

  @__uint64_t()
  external int oldmask;

  @__uint64_t()
  external int cr2;

  external UnnamedUnion1 unnamed;

  @ffi.Array.multi([8])
  external ffi.Array<__uint64_t> __reserved1;
}

final class _xsave_hdr extends ffi.Struct {
  @__uint64_t()
  external int xstate_bv;

  @ffi.Array.multi([2])
  external ffi.Array<__uint64_t> __glibc_reserved1;

  @ffi.Array.multi([5])
  external ffi.Array<__uint64_t> __glibc_reserved2;
}

final class _ymmh_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> ymmh_space;
}

final class _xstate extends ffi.Struct {
  external _fpstate fpstate;

  external _xsave_hdr xstate_hdr;

  external _ymmh_state ymmh;
}

typedef greg_t = ffi.LongLong;
typedef Dartgreg_t = int;

final class _libc_fpxreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> significand;

  @ffi.UnsignedShort()
  external int exponent;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __glibc_reserved1;
}

final class _libc_xmmreg extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__uint32_t> element;
}

final class _libc_fpstate extends ffi.Struct {
  @__uint16_t()
  external int cwd;

  @__uint16_t()
  external int swd;

  @__uint16_t()
  external int ftw;

  @__uint16_t()
  external int fop;

  @__uint64_t()
  external int rip;

  @__uint64_t()
  external int rdp;

  @__uint32_t()
  external int mxcsr;

  @__uint32_t()
  external int mxcr_mask;

  @ffi.Array.multi([8])
  external ffi.Array<_libc_fpxreg> _st;

  @ffi.Array.multi([16])
  external ffi.Array<_libc_xmmreg> _xmm;

  @ffi.Array.multi([24])
  external ffi.Array<__uint32_t> __glibc_reserved1;
}

typedef fpregset_t = ffi.Pointer<_libc_fpstate>;

final class mcontext_t extends ffi.Struct {
  @ffi.Array.multi([23])
  external ffi.Array<greg_t> gregs;

  external fpregset_t fpregs;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedLongLong> __reserved1;
}

final class stack_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @ffi.Int()
  external int ss_flags;

  @ffi.Size()
  external int ss_size;
}

final class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

typedef sigset_t = __sigset_t;

final class ucontext_t extends ffi.Struct {
  @ffi.UnsignedLong()
  external int uc_flags;

  external ffi.Pointer<ucontext_t> uc_link;

  external stack_t uc_stack;

  external mcontext_t uc_mcontext;

  external sigset_t uc_sigmask;

  external _libc_fpstate __fpregs_mem;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedLongLong> __ssp;
}

/// \addtogroup spa_dict
/// \{
final class spa_dict_item extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

final class spa_dict extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  @ffi.Uint32()
  external int n_items;

  external ffi.Pointer<spa_dict_item> items;
}

/// \addtogroup spa_handle
/// \{
final class spa_handle extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Get the interface provided by \a handle with \a type.
  ///
  /// \a interface is always a struct spa_interface but depending on
  /// \a type, the struct might contain other information.
  ///
  /// \param handle a spa_handle
  /// \param type the interface type
  /// \param interface result to hold the interface.
  /// \return 0 on success
  /// -ENOTSUP when there are no interfaces
  /// -EINVAL when handle or info is NULL
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<spa_handle> handle,
              ffi.Pointer<ffi.Char> type,
              ffi.Pointer<ffi.Pointer<ffi.Void>> interface$)>> get_interface;

  /// Clean up the memory of \a handle. After this, \a handle should not be used
  /// anymore.
  ///
  /// \param handle a pointer to memory
  /// \return 0 on success
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<spa_handle> handle)>>
      clear;
}

/// This structure lists the information about available interfaces on
/// handles.
final class spa_interface_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type;
}

/// Extra supporting infrastructure passed to the init() function of
/// a factory. It can be extra information or interfaces such as logging.
final class spa_support extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type;

  external ffi.Pointer<ffi.Void> data;
}

final class spa_handle_factory extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The name of the factory contains a logical name that describes
  /// the function of the handle. Other plugins might contain an alternative
  /// implementation with the same name.
  ///
  /// See utils/names.h for the list of standard names.
  ///
  /// Examples include:
  ///
  /// api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK
  /// device
  /// api.v4l2.source: an object to read from a v4l2 source.
  external ffi.Pointer<ffi.Char> name;

  /// Extra information about the handles of this factory.
  external ffi.Pointer<spa_dict> info;

  /// Get the size of handles from this factory.
  ///
  /// \param factory a spa_handle_factory
  /// \param params extra parameters that determine the size of the
  /// handle.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<spa_handle_factory> factory$,
              ffi.Pointer<spa_dict> params)>> get_size;

  /// Initialize an instance of this factory. The caller should allocate
  /// memory at least size bytes and pass this as \a handle.
  ///
  /// \a support can optionally contain extra interfaces or data items that the
  /// plugin can use such as a logger.
  ///
  /// \param factory a spa_handle_factory
  /// \param handle a pointer to memory
  /// \param info extra handle specific information, usually obtained
  /// from a spa_device. This can be used to configure the handle.
  /// \param support support items
  /// \param n_support number of elements in \a support
  /// \return 0 on success
  /// < 0 errno type error
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<spa_handle_factory> factory$,
              ffi.Pointer<spa_handle> handle,
              ffi.Pointer<spa_dict> info,
              ffi.Pointer<spa_support> support,
              ffi.Uint32 n_support)>> init;

  /// spa_handle_factory::enum_interface_info:
  /// \param factory: a #spa_handle_factory
  /// \param info: result to hold spa_interface_info.
  /// \param index: index to keep track of the enumeration, 0 for first item
  ///
  /// Enumerate the interface information for \a factory.
  ///
  /// \return 1 when an item is available
  /// 0 when no more items are available
  /// < 0 errno type error
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<spa_handle_factory> factory$,
              ffi.Pointer<ffi.Pointer<spa_interface_info>> info,
              ffi.Pointer<ffi.Uint32> index)>> enum_interface_info;
}

typedef spa_handle_factory_enum_func_tFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<spa_handle_factory>> factory$,
    ffi.Pointer<ffi.Uint32> index);
typedef Dartspa_handle_factory_enum_func_tFunction = int Function(
    ffi.Pointer<ffi.Pointer<spa_handle_factory>> factory$,
    ffi.Pointer<ffi.Uint32> index);

/// The function signature of the entry point in a plugin.
///
/// \param factory a location to hold the factory result
/// \param index index to keep track of the enumeration
/// \return 1 on success
/// 0 when there are no more factories
/// -EINVAL when factory is NULL
typedef spa_handle_factory_enum_func_t
    = ffi.Pointer<ffi.NativeFunction<spa_handle_factory_enum_func_tFunction>>;

/// \struct spa_callbacks
/// Callbacks, contains the structure with functions and the data passed
/// to the functions.  The structure should also contain a version field that
/// is checked.
final class spa_callbacks extends ffi.Struct {
  external ffi.Pointer<ffi.Void> funcs;

  external ffi.Pointer<ffi.Void> data;
}

/// \struct spa_interface
final class spa_interface extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type;

  @ffi.Uint32()
  external int version;

  external spa_callbacks cb;
}

/// \addtogroup spa_list List
/// \{
final class spa_list extends ffi.Struct {
  external ffi.Pointer<spa_list> next;

  external ffi.Pointer<spa_list> prev;
}

/// \struct spa_hook_list
/// A list of hooks. This struct is primarily used by
/// implementation that use multiple caller-provided \ref spa_hook.
final class spa_hook_list extends ffi.Struct {
  external spa_list list;
}

/// \struct spa_hook
/// A hook, contains the structure with functions and the data passed
/// to the functions.
///
/// A hook should be treated as opaque by the caller.
final class spa_hook extends ffi.Struct {
  external spa_list link;

  external spa_callbacks cb;

  /// callback and data for the hook list, private to the
  /// hook_list implementor
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<spa_hook> hook)>>
      removed;

  external ffi.Pointer<ffi.Void> priv;
}

/// \addtogroup pw_context
/// @{
final class pw_context extends ffi.Opaque {}

final class pw_global extends ffi.Opaque {}

final class pw_impl_client extends ffi.Opaque {}

final class pw_core extends ffi.Opaque {}

final class pw_registry extends ffi.Opaque {}

/// The core information. Extra information may be added in later versions,
/// clients must not assume a constant struct size
final class pw_core_info extends ffi.Struct {
  /// < id of the global
  @ffi.Uint32()
  external int id;

  /// < a random cookie for identifying this instance of PipeWire
  @ffi.Uint32()
  external int cookie;

  /// < name of the user that started the core
  external ffi.Pointer<ffi.Char> user_name;

  /// < name of the machine the core is running on
  external ffi.Pointer<ffi.Char> host_name;

  /// < version of the core
  external ffi.Pointer<ffi.Char> version;

  /// < name of the core
  external ffi.Pointer<ffi.Char> name;

  /// < bitfield of changed fields since last call
  @ffi.Uint64()
  external int change_mask;

  /// < extra properties
  external ffi.Pointer<spa_dict> props;
}

/// \struct pw_core_events
/// \brief Core events
final class pw_core_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify new core info
  ///
  /// This event is emitted when first bound to the core or when the
  /// hello method is called.
  ///
  /// \param info new core info
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> object,
              ffi.Pointer<pw_core_info> info)>> info;

  /// Emit a done event
  ///
  /// The done event is emitted as a result of a sync method with the
  /// same seq number.
  ///
  /// \param seq the seq number passed to the sync method call
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void> object, ffi.Uint32 id, ffi.Int seq)>> done;

  /// Emit a ping event
  ///
  /// The client should reply with a pong reply with the same seq
  /// number.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void> object, ffi.Uint32 id, ffi.Int seq)>> ping;

  /// Fatal error event
  ///
  /// The error event is sent out when a fatal (non-recoverable)
  /// error has occurred. The id argument is the proxy object where
  /// the error occurred, most often in response to a request to that
  /// object. The message is a brief description of the error,
  /// for (debugging) convenience.
  ///
  /// This event is usually also emitted on the proxy object with
  /// \a id.
  ///
  /// \param id object where the error occurred
  /// \param seq the sequence number that generated the error
  /// \param res error code
  /// \param message error description
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id,
              ffi.Int seq, ffi.Int res, ffi.Pointer<ffi.Char> message)>> error;

  /// Remove an object ID
  ///
  /// This event is used internally by the object ID management
  /// logic. When a client deletes an object, the server will send
  /// this event to acknowledge that it has seen the delete request.
  /// When the client receives this event, it will know that it can
  /// safely reuse the object ID.
  ///
  /// \param id deleted object ID
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id)>>
      remove_id;

  /// Notify an object binding
  ///
  /// This event is emitted when a local object ID is bound to a
  /// global ID. It is emitted before the global becomes visible in the
  /// registry.
  ///
  /// \param id bound object ID
  /// \param global_id the global id bound to
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id,
              ffi.Uint32 global_id)>> bound_id;

  /// Add memory for a client
  ///
  /// Memory is given to a client as \a fd of a certain
  /// memory \a type.
  ///
  /// Further references to this fd will be made with the per memory
  /// unique identifier \a id.
  ///
  /// \param id the unique id of the memory
  /// \param type the memory type, one of enum spa_data_type
  /// \param fd the file descriptor
  /// \param flags extra flags
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id,
              ffi.Uint32 type, ffi.Int fd, ffi.Uint32 flags)>> add_mem;

  /// Remove memory for a client
  ///
  /// \param id the memory id to remove
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id)>>
      remove_mem;
}

/// \struct pw_core_methods
/// \brief Core methods
///
/// The core global object. This is a singleton object used for
/// creating new objects in the remote PipeWire instance. It is
/// also used for internal features.
final class pw_core_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> object,
              ffi.Pointer<spa_hook> listener,
              ffi.Pointer<pw_core_events> events,
              ffi.Pointer<ffi.Void> data)>> add_listener;

  /// Start a conversation with the server. This will send
  /// the core info and will destroy all resources for the client
  /// (except the core and client resource).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> object, ffi.Uint32 version)>> hello;

  /// Do server roundtrip
  ///
  /// Ask the server to emit the 'done' event with \a seq.
  ///
  /// Since methods are handled in-order and events are delivered
  /// in-order, this can be used as a barrier to ensure all previous
  /// methods and the resulting events have been handled.
  ///
  /// \param seq the seq number passed to the done event
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> object, ffi.Uint32 id, ffi.Int seq)>> sync$;

  /// Reply to a server ping event.
  ///
  /// Reply to the server ping event with the same seq.
  ///
  /// \param seq the seq number received in the ping event
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> object, ffi.Uint32 id, ffi.Int seq)>> pong;

  /// Fatal error event
  ///
  /// The error method is sent out when a fatal (non-recoverable)
  /// error has occurred. The id argument is the proxy object where
  /// the error occurred, most often in response to an event on that
  /// object. The message is a brief description of the error,
  /// for (debugging) convenience.
  ///
  /// This method is usually also emitted on the resource object with
  /// \a id.
  ///
  /// \param id object where the error occurred
  /// \param res error code
  /// \param message error description
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id,
              ffi.Int seq, ffi.Int res, ffi.Pointer<ffi.Char> message)>> error;

  /// Get the registry object
  ///
  /// Create a registry object that allows the client to list and bind
  /// the global objects available from the PipeWire server
  /// \param version the client version
  /// \param user_data_size extra size
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_registry> Function(ffi.Pointer<ffi.Void> object,
              ffi.Uint32 version, ffi.Size user_data_size)>> get_registry;

  /// Create a new object on the PipeWire server from a factory.
  ///
  /// \param factory_name the factory name to use
  /// \param type the interface to bind to
  /// \param version the version of the interface
  /// \param props extra properties
  /// \param user_data_size extra size
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void> object,
              ffi.Pointer<ffi.Char> factory_name,
              ffi.Pointer<ffi.Char> type,
              ffi.Uint32 version,
              ffi.Pointer<spa_dict> props,
              ffi.Size user_data_size)>> create_object;

  /// Destroy an resource
  ///
  /// Destroy the server resource for the given proxy.
  ///
  /// \param obj the proxy to destroy
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> object, ffi.Pointer<ffi.Void> proxy)>>
      destroy;
}

/// Registry events
final class pw_registry_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Notify of a new global object
  ///
  /// The registry emits this event when a new global object is
  /// available.
  ///
  /// \param id the global object id
  /// \param permissions the permissions of the object
  /// \param type the type of the interface
  /// \param version the version of the interface
  /// \param props extra properties of the global
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void> object,
              ffi.Uint32 id,
              ffi.Uint32 permissions,
              ffi.Pointer<ffi.Char> type,
              ffi.Uint32 version,
              ffi.Pointer<spa_dict> props)>> global;

  /// Notify of a global object removal
  ///
  /// Emitted when a global object was removed from the registry.
  /// If the client has any bindings to the global, it should destroy
  /// those.
  ///
  /// \param id the id of the global that was removed
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id)>>
      global_remove;
}

/// Registry methods
final class pw_registry_methods extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> object,
              ffi.Pointer<spa_hook> listener,
              ffi.Pointer<pw_registry_events> events,
              ffi.Pointer<ffi.Void> data)>> add_listener;

  /// Bind to a global object
  ///
  /// Bind to the global object with \a id and use the client proxy
  /// with new_id as the proxy. After this call, methods can be
  /// send to the remote global object and events can be received
  ///
  /// \param id the global id to bind to
  /// \param type the interface type to bind to
  /// \param version the interface version to use
  /// \returns the new object
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void> object,
              ffi.Uint32 id,
              ffi.Pointer<ffi.Char> type,
              ffi.Uint32 version,
              ffi.Size use_data_size)>> bind;

  /// Attempt to destroy a global object
  ///
  /// Try to destroy the global object.
  ///
  /// \param id the global id to destroy
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void> object, ffi.Uint32 id)>>
      destroy;
}

/// \addtogroup pw_properties
/// \{
final class pw_properties extends ffi.Struct {
  /// < dictionary of key/values
  external spa_dict dict;

  /// < extra flags
  @ffi.Uint32()
  external int flags;
}

final class pw_client extends ffi.Opaque {}

/// A memory pool is a collection of pw_memblocks
final class pw_mempool extends ffi.Struct {
  external ffi.Pointer<pw_properties> props;
}

/// \addtogroup pw_proxy
/// \{
final class pw_proxy extends ffi.Opaque {}

/// context events emitted by the context object added with \ref pw_context_add_listener
final class pw_context_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The context is being destroyed
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      destroy;

  /// The context is being freed
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>> free;

  /// a new client object is added
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data,
              ffi.Pointer<pw_impl_client> client)>> check_access;

  /// a new global object was added
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> data, ffi.Pointer<pw_global> global)>>
      global_added;

  /// a global object was removed
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> data, ffi.Pointer<pw_global> global)>>
      global_removed;
}

final class spa_system extends ffi.Struct {
  external spa_interface iface;
}

final class spa_loop extends ffi.Struct {
  external spa_interface iface;
}

final class spa_loop_control extends ffi.Struct {
  external spa_interface iface;
}

final class spa_loop_utils extends ffi.Struct {
  external spa_interface iface;
}

/// \addtogroup pw_loop
/// \{
final class pw_loop extends ffi.Struct {
  /// < system utils
  external ffi.Pointer<spa_system> system;

  /// < wrapped loop
  external ffi.Pointer<spa_loop> loop;

  /// < loop control
  external ffi.Pointer<spa_loop_control> control;

  /// < loop utils
  external ffi.Pointer<spa_loop_utils> utils;
}

final class pw_work_queue extends ffi.Opaque {}

/// data for registering export functions
final class pw_export_type extends ffi.Struct {
  external spa_list link;

  external ffi.Pointer<ffi.Char> type;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<pw_proxy> Function(
              ffi.Pointer<pw_core> core,
              ffi.Pointer<ffi.Char> type,
              ffi.Pointer<spa_dict> props,
              ffi.Pointer<ffi.Void> object,
              ffi.Size user_data_size)>> func;
}

/// A main loop object
final class pw_main_loop extends ffi.Opaque {}

/// Events of the main loop
final class pw_main_loop_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Emitted when the main loop is destroyed
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      destroy;
}

/// \addtogroup pw_stream
/// \{
final class pw_stream extends ffi.Opaque {}

/// \enum pw_stream_state The state of a stream
enum pw_stream_state {
  /// < the stream is in error
  PW_STREAM_STATE_ERROR(-1),

  /// < unconnected
  PW_STREAM_STATE_UNCONNECTED(0),

  /// < connection is in progress
  PW_STREAM_STATE_CONNECTING(1),

  /// < paused
  PW_STREAM_STATE_PAUSED(2),

  /// < streaming
  PW_STREAM_STATE_STREAMING(3);

  final int value;
  const pw_stream_state(this.value);

  static pw_stream_state fromValue(int value) => switch (value) {
        -1 => PW_STREAM_STATE_ERROR,
        0 => PW_STREAM_STATE_UNCONNECTED,
        1 => PW_STREAM_STATE_CONNECTING,
        2 => PW_STREAM_STATE_PAUSED,
        3 => PW_STREAM_STATE_STREAMING,
        _ => throw ArgumentError('Unknown value for pw_stream_state: $value'),
      };
}

/// A metadata element.
///
/// This structure is available on the buffer structure and contains
/// the type of the metadata and a pointer/size to the actual metadata
/// itself.
final class spa_meta extends ffi.Struct {
  /// < metadata type, one of enum spa_meta_type
  @ffi.Uint32()
  external int type;

  /// < size of metadata
  @ffi.Uint32()
  external int size;

  /// < pointer to metadata
  external ffi.Pointer<ffi.Void> data;
}

/// Chunk of memory, can change for each buffer
final class spa_chunk extends ffi.Struct {
  /// < offset of valid data. Should be taken
  /// modulo the data maxsize to get the offset
  /// in the data memory.
  @ffi.Uint32()
  external int offset;

  /// < size of valid data. Should be clamped to
  /// maxsize.
  @ffi.Uint32()
  external int size;

  /// < stride of valid data
  @ffi.Int32()
  external int stride;

  /// < chunk flags
  @ffi.Int32()
  external int flags;
}

/// Data for a buffer this stays constant for a buffer
final class spa_data extends ffi.Struct {
  /// < memory type, one of enum spa_data_type, when
  /// allocating memory, the type contains a bitmask
  /// of allowed types. SPA_ID_INVALID is a special
  /// value for the allocator to indicate that the
  /// other side did not explicitly specify any
  /// supported data types. It should probably use
  /// a memory type that does not require special
  /// handling in addition to simple mmap/munmap.
  @ffi.Uint32()
  external int type;

  /// < data flags
  @ffi.Uint32()
  external int flags;

  /// < optional fd for data
  @ffi.Int64()
  external int fd;

  /// < offset to map fd at
  @ffi.Uint32()
  external int mapoffset;

  /// < max size of data
  @ffi.Uint32()
  external int maxsize;

  /// < optional data pointer
  external ffi.Pointer<ffi.Void> data;

  /// < valid chunk of memory
  external ffi.Pointer<spa_chunk> chunk;
}

/// A Buffer
final class spa_buffer extends ffi.Struct {
  /// < number of metadata
  @ffi.Uint32()
  external int n_metas;

  /// < number of data members
  @ffi.Uint32()
  external int n_datas;

  /// < array of metadata
  external ffi.Pointer<spa_meta> metas;

  /// < array of data members
  external ffi.Pointer<spa_data> datas;
}

final class pw_buffer extends ffi.Struct {
  /// < the spa buffer
  external ffi.Pointer<spa_buffer> buffer;

  /// < user data attached to the buffer
  external ffi.Pointer<ffi.Void> user_data;

  /// < This field is set by the user and the sum of
  /// all queued buffer is returned in the time info
  @ffi.Uint64()
  external int size;
}

final class pw_stream_control extends ffi.Struct {
  /// < name of the control
  external ffi.Pointer<ffi.Char> name;

  /// < extra flags (unused)
  @ffi.Uint32()
  external int flags;

  /// < default value
  @ffi.Float()
  external double def;

  /// < min value
  @ffi.Float()
  external double min;

  /// < max value
  @ffi.Float()
  external double max;

  /// < array of values
  external ffi.Pointer<ffi.Float> values;

  /// < number of values in array
  @ffi.Uint32()
  external int n_values;

  /// < max values that can be set on this control
  @ffi.Uint32()
  external int max_values;
}

final class spa_fraction extends ffi.Struct {
  @ffi.Uint32()
  external int num;

  @ffi.Uint32()
  external int denom;
}

/// A time structure
final class pw_time extends ffi.Struct {
  /// < the monotonic time in nanoseconds
  @ffi.Int64()
  external int now;

  /// < the rate of \a ticks and delay
  external spa_fraction rate;

  /// < the ticks at \a now. This is the current time that
  /// the remote end is reading/writing.
  @ffi.Uint64()
  external int ticks;

  /// < delay to device, add to ticks to get the time of the
  /// device. Positive for INPUT streams and
  /// negative for OUTPUT streams.
  @ffi.Int64()
  external int delay;

  /// < data queued in the stream, this is the sum
  /// of the size fields in the pw_buffer that are
  /// currently queued
  @ffi.Uint64()
  external int queued;
}

final class spa_pod extends ffi.Struct {
  @ffi.Uint32()
  external int size;

  @ffi.Uint32()
  external int type;
}

final class spa_pod_object_body extends ffi.Struct {
  /// < one of enum spa_type
  @ffi.Uint32()
  external int type;

  /// < id of the object, depends on the object type
  @ffi.Uint32()
  external int id;
}

/// \addtogroup spa_pod
/// \{
final class spa_command_body extends ffi.Struct {
  external spa_pod_object_body body;
}

final class spa_command extends ffi.Struct {
  external spa_pod pod;

  external spa_command_body body;
}

/// Events for a stream. These events are always called from the mainloop
/// unless explicitly documented otherwise.
final class pw_stream_events extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      destroy;

  /// when the stream state changes
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data, ffi.Int old,
              ffi.Int state, ffi.Pointer<ffi.Char> error)>> state_changed;

  /// Notify information about a control.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data, ffi.Uint32 id,
              ffi.Pointer<pw_stream_control> control)>> control_info;

  /// when io changed on the stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data, ffi.Uint32 id,
              ffi.Pointer<ffi.Void> area, ffi.Uint32 size)>> io_changed;

  /// when a parameter changed
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data, ffi.Uint32 id,
              ffi.Pointer<spa_pod> param)>> param_changed;

  /// when a new buffer was created for this stream
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> data, ffi.Pointer<pw_buffer> buffer)>>
      add_buffer;

  /// when a buffer was destroyed for this stream
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> data, ffi.Pointer<pw_buffer> buffer)>>
      remove_buffer;

  /// when a buffer can be queued (for playback streams) or
  /// dequeued (for capture streams). This is normally called from the
  /// mainloop but can also be called directly from the realtime data
  /// thread if the user is prepared to deal with this.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      process;

  /// The stream is drained
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      drained;

  /// A command notify, Since 0.3.39:1
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> data,
              ffi.Pointer<spa_command> command)>> command;

  /// a trigger_process completed. Since version 0.3.40:2
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> data)>>
      trigger_done;
}

/// \enum pw_stream_flags Extra flags that can be used in \ref pw_stream_connect()
enum pw_stream_flags {
  /// < no flags
  PW_STREAM_FLAG_NONE(0),

  /// < try to automatically connect
  /// this stream
  PW_STREAM_FLAG_AUTOCONNECT(1),

  /// < start the stream inactive,
  /// pw_stream_set_active() needs to be
  /// called explicitly
  PW_STREAM_FLAG_INACTIVE(2),

  /// < mmap the buffers except DmaBuf
  PW_STREAM_FLAG_MAP_BUFFERS(4),

  /// < be a driver
  PW_STREAM_FLAG_DRIVER(8),

  /// < call process from the realtime
  /// thread. You MUST use RT safe functions
  /// in the process callback.
  PW_STREAM_FLAG_RT_PROCESS(16),

  /// < don't convert format
  PW_STREAM_FLAG_NO_CONVERT(32),

  /// < require exclusive access to the
  /// device
  PW_STREAM_FLAG_EXCLUSIVE(64),

  /// < don't try to reconnect this stream
  /// when the sink/source is removed
  PW_STREAM_FLAG_DONT_RECONNECT(128),

  /// < the application will allocate buffer
  /// memory. In the add_buffer event, the
  /// data of the buffer should be set
  PW_STREAM_FLAG_ALLOC_BUFFERS(256),

  /// < the output stream will not be scheduled
  /// automatically but _trigger_process()
  /// needs to be called. This can be used
  /// when the output of the stream depends
  /// on input from other streams.
  PW_STREAM_FLAG_TRIGGER(512);

  final int value;
  const pw_stream_flags(this.value);

  static pw_stream_flags fromValue(int value) => switch (value) {
        0 => PW_STREAM_FLAG_NONE,
        1 => PW_STREAM_FLAG_AUTOCONNECT,
        2 => PW_STREAM_FLAG_INACTIVE,
        4 => PW_STREAM_FLAG_MAP_BUFFERS,
        8 => PW_STREAM_FLAG_DRIVER,
        16 => PW_STREAM_FLAG_RT_PROCESS,
        32 => PW_STREAM_FLAG_NO_CONVERT,
        64 => PW_STREAM_FLAG_EXCLUSIVE,
        128 => PW_STREAM_FLAG_DONT_RECONNECT,
        256 => PW_STREAM_FLAG_ALLOC_BUFFERS,
        512 => PW_STREAM_FLAG_TRIGGER,
        _ => throw ArgumentError('Unknown value for pw_stream_flags: $value'),
      };
}

enum spa_direction {
  SPA_DIRECTION_INPUT(0),
  SPA_DIRECTION_OUTPUT(1);

  final int value;
  const spa_direction(this.value);

  static spa_direction fromValue(int value) => switch (value) {
        0 => SPA_DIRECTION_INPUT,
        1 => SPA_DIRECTION_OUTPUT,
        _ => throw ArgumentError('Unknown value for spa_direction: $value'),
      };
}

/// Video formats
///
/// The components are in general described in big-endian order. There are some
/// exceptions (e.g. RGB15 and RGB16) which use the host endianness.
///
/// Most of the formats are identical to their GStreamer equivalent. See the
/// GStreamer video formats documentation for more details:
///
/// https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats
enum spa_video_format {
  SPA_VIDEO_FORMAT_UNKNOWN(0),
  SPA_VIDEO_FORMAT_ENCODED(1),
  SPA_VIDEO_FORMAT_I420(2),
  SPA_VIDEO_FORMAT_YV12(3),
  SPA_VIDEO_FORMAT_YUY2(4),
  SPA_VIDEO_FORMAT_UYVY(5),
  SPA_VIDEO_FORMAT_AYUV(6),
  SPA_VIDEO_FORMAT_RGBx(7),
  SPA_VIDEO_FORMAT_BGRx(8),
  SPA_VIDEO_FORMAT_xRGB(9),
  SPA_VIDEO_FORMAT_xBGR(10),
  SPA_VIDEO_FORMAT_RGBA(11),
  SPA_VIDEO_FORMAT_BGRA(12),
  SPA_VIDEO_FORMAT_ARGB(13),
  SPA_VIDEO_FORMAT_ABGR(14),
  SPA_VIDEO_FORMAT_RGB(15),
  SPA_VIDEO_FORMAT_BGR(16),
  SPA_VIDEO_FORMAT_Y41B(17),
  SPA_VIDEO_FORMAT_Y42B(18),
  SPA_VIDEO_FORMAT_YVYU(19),
  SPA_VIDEO_FORMAT_Y444(20),
  SPA_VIDEO_FORMAT_v210(21),
  SPA_VIDEO_FORMAT_v216(22),
  SPA_VIDEO_FORMAT_NV12(23),
  SPA_VIDEO_FORMAT_NV21(24),
  SPA_VIDEO_FORMAT_GRAY8(25),
  SPA_VIDEO_FORMAT_GRAY16_BE(26),
  SPA_VIDEO_FORMAT_GRAY16_LE(27),
  SPA_VIDEO_FORMAT_v308(28),
  SPA_VIDEO_FORMAT_RGB16(29),
  SPA_VIDEO_FORMAT_BGR16(30),
  SPA_VIDEO_FORMAT_RGB15(31),
  SPA_VIDEO_FORMAT_BGR15(32),
  SPA_VIDEO_FORMAT_UYVP(33),
  SPA_VIDEO_FORMAT_A420(34),
  SPA_VIDEO_FORMAT_RGB8P(35),
  SPA_VIDEO_FORMAT_YUV9(36),
  SPA_VIDEO_FORMAT_YVU9(37),
  SPA_VIDEO_FORMAT_IYU1(38),
  SPA_VIDEO_FORMAT_ARGB64(39),
  SPA_VIDEO_FORMAT_AYUV64(40),
  SPA_VIDEO_FORMAT_r210(41),
  SPA_VIDEO_FORMAT_I420_10BE(42),
  SPA_VIDEO_FORMAT_I420_10LE(43),
  SPA_VIDEO_FORMAT_I422_10BE(44),
  SPA_VIDEO_FORMAT_I422_10LE(45),
  SPA_VIDEO_FORMAT_Y444_10BE(46),
  SPA_VIDEO_FORMAT_Y444_10LE(47),
  SPA_VIDEO_FORMAT_GBR(48),
  SPA_VIDEO_FORMAT_GBR_10BE(49),
  SPA_VIDEO_FORMAT_GBR_10LE(50),
  SPA_VIDEO_FORMAT_NV16(51),
  SPA_VIDEO_FORMAT_NV24(52),
  SPA_VIDEO_FORMAT_NV12_64Z32(53),
  SPA_VIDEO_FORMAT_A420_10BE(54),
  SPA_VIDEO_FORMAT_A420_10LE(55),
  SPA_VIDEO_FORMAT_A422_10BE(56),
  SPA_VIDEO_FORMAT_A422_10LE(57),
  SPA_VIDEO_FORMAT_A444_10BE(58),
  SPA_VIDEO_FORMAT_A444_10LE(59),
  SPA_VIDEO_FORMAT_NV61(60),
  SPA_VIDEO_FORMAT_P010_10BE(61),
  SPA_VIDEO_FORMAT_P010_10LE(62),
  SPA_VIDEO_FORMAT_IYU2(63),
  SPA_VIDEO_FORMAT_VYUY(64),
  SPA_VIDEO_FORMAT_GBRA(65),
  SPA_VIDEO_FORMAT_GBRA_10BE(66),
  SPA_VIDEO_FORMAT_GBRA_10LE(67),
  SPA_VIDEO_FORMAT_GBR_12BE(68),
  SPA_VIDEO_FORMAT_GBR_12LE(69),
  SPA_VIDEO_FORMAT_GBRA_12BE(70),
  SPA_VIDEO_FORMAT_GBRA_12LE(71),
  SPA_VIDEO_FORMAT_I420_12BE(72),
  SPA_VIDEO_FORMAT_I420_12LE(73),
  SPA_VIDEO_FORMAT_I422_12BE(74),
  SPA_VIDEO_FORMAT_I422_12LE(75),
  SPA_VIDEO_FORMAT_Y444_12BE(76),
  SPA_VIDEO_FORMAT_Y444_12LE(77),
  SPA_VIDEO_FORMAT_RGBA_F16(78),
  SPA_VIDEO_FORMAT_RGBA_F32(79),

  /// < 32-bit x:R:G:B 2:10:10:10 little endian
  SPA_VIDEO_FORMAT_xRGB_210LE(80),

  /// < 32-bit x:B:G:R 2:10:10:10 little endian
  SPA_VIDEO_FORMAT_xBGR_210LE(81),

  /// < 32-bit R:G:B:x 10:10:10:2 little endian
  SPA_VIDEO_FORMAT_RGBx_102LE(82),

  /// < 32-bit B:G:R:x 10:10:10:2 little endian
  SPA_VIDEO_FORMAT_BGRx_102LE(83),

  /// < 32-bit A:R:G:B 2:10:10:10 little endian
  SPA_VIDEO_FORMAT_ARGB_210LE(84),

  /// < 32-bit A:B:G:R 2:10:10:10 little endian
  SPA_VIDEO_FORMAT_ABGR_210LE(85),

  /// < 32-bit R:G:B:A 10:10:10:2 little endian
  SPA_VIDEO_FORMAT_RGBA_102LE(86),

  /// < 32-bit B:G:R:A 10:10:10:2 little endian
  SPA_VIDEO_FORMAT_BGRA_102LE(87);

  static const SPA_VIDEO_FORMAT_DSP_F32 = SPA_VIDEO_FORMAT_RGBA_F32;

  final int value;
  const spa_video_format(this.value);

  static spa_video_format fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_FORMAT_UNKNOWN,
        1 => SPA_VIDEO_FORMAT_ENCODED,
        2 => SPA_VIDEO_FORMAT_I420,
        3 => SPA_VIDEO_FORMAT_YV12,
        4 => SPA_VIDEO_FORMAT_YUY2,
        5 => SPA_VIDEO_FORMAT_UYVY,
        6 => SPA_VIDEO_FORMAT_AYUV,
        7 => SPA_VIDEO_FORMAT_RGBx,
        8 => SPA_VIDEO_FORMAT_BGRx,
        9 => SPA_VIDEO_FORMAT_xRGB,
        10 => SPA_VIDEO_FORMAT_xBGR,
        11 => SPA_VIDEO_FORMAT_RGBA,
        12 => SPA_VIDEO_FORMAT_BGRA,
        13 => SPA_VIDEO_FORMAT_ARGB,
        14 => SPA_VIDEO_FORMAT_ABGR,
        15 => SPA_VIDEO_FORMAT_RGB,
        16 => SPA_VIDEO_FORMAT_BGR,
        17 => SPA_VIDEO_FORMAT_Y41B,
        18 => SPA_VIDEO_FORMAT_Y42B,
        19 => SPA_VIDEO_FORMAT_YVYU,
        20 => SPA_VIDEO_FORMAT_Y444,
        21 => SPA_VIDEO_FORMAT_v210,
        22 => SPA_VIDEO_FORMAT_v216,
        23 => SPA_VIDEO_FORMAT_NV12,
        24 => SPA_VIDEO_FORMAT_NV21,
        25 => SPA_VIDEO_FORMAT_GRAY8,
        26 => SPA_VIDEO_FORMAT_GRAY16_BE,
        27 => SPA_VIDEO_FORMAT_GRAY16_LE,
        28 => SPA_VIDEO_FORMAT_v308,
        29 => SPA_VIDEO_FORMAT_RGB16,
        30 => SPA_VIDEO_FORMAT_BGR16,
        31 => SPA_VIDEO_FORMAT_RGB15,
        32 => SPA_VIDEO_FORMAT_BGR15,
        33 => SPA_VIDEO_FORMAT_UYVP,
        34 => SPA_VIDEO_FORMAT_A420,
        35 => SPA_VIDEO_FORMAT_RGB8P,
        36 => SPA_VIDEO_FORMAT_YUV9,
        37 => SPA_VIDEO_FORMAT_YVU9,
        38 => SPA_VIDEO_FORMAT_IYU1,
        39 => SPA_VIDEO_FORMAT_ARGB64,
        40 => SPA_VIDEO_FORMAT_AYUV64,
        41 => SPA_VIDEO_FORMAT_r210,
        42 => SPA_VIDEO_FORMAT_I420_10BE,
        43 => SPA_VIDEO_FORMAT_I420_10LE,
        44 => SPA_VIDEO_FORMAT_I422_10BE,
        45 => SPA_VIDEO_FORMAT_I422_10LE,
        46 => SPA_VIDEO_FORMAT_Y444_10BE,
        47 => SPA_VIDEO_FORMAT_Y444_10LE,
        48 => SPA_VIDEO_FORMAT_GBR,
        49 => SPA_VIDEO_FORMAT_GBR_10BE,
        50 => SPA_VIDEO_FORMAT_GBR_10LE,
        51 => SPA_VIDEO_FORMAT_NV16,
        52 => SPA_VIDEO_FORMAT_NV24,
        53 => SPA_VIDEO_FORMAT_NV12_64Z32,
        54 => SPA_VIDEO_FORMAT_A420_10BE,
        55 => SPA_VIDEO_FORMAT_A420_10LE,
        56 => SPA_VIDEO_FORMAT_A422_10BE,
        57 => SPA_VIDEO_FORMAT_A422_10LE,
        58 => SPA_VIDEO_FORMAT_A444_10BE,
        59 => SPA_VIDEO_FORMAT_A444_10LE,
        60 => SPA_VIDEO_FORMAT_NV61,
        61 => SPA_VIDEO_FORMAT_P010_10BE,
        62 => SPA_VIDEO_FORMAT_P010_10LE,
        63 => SPA_VIDEO_FORMAT_IYU2,
        64 => SPA_VIDEO_FORMAT_VYUY,
        65 => SPA_VIDEO_FORMAT_GBRA,
        66 => SPA_VIDEO_FORMAT_GBRA_10BE,
        67 => SPA_VIDEO_FORMAT_GBRA_10LE,
        68 => SPA_VIDEO_FORMAT_GBR_12BE,
        69 => SPA_VIDEO_FORMAT_GBR_12LE,
        70 => SPA_VIDEO_FORMAT_GBRA_12BE,
        71 => SPA_VIDEO_FORMAT_GBRA_12LE,
        72 => SPA_VIDEO_FORMAT_I420_12BE,
        73 => SPA_VIDEO_FORMAT_I420_12LE,
        74 => SPA_VIDEO_FORMAT_I422_12BE,
        75 => SPA_VIDEO_FORMAT_I422_12LE,
        76 => SPA_VIDEO_FORMAT_Y444_12BE,
        77 => SPA_VIDEO_FORMAT_Y444_12LE,
        78 => SPA_VIDEO_FORMAT_RGBA_F16,
        79 => SPA_VIDEO_FORMAT_RGBA_F32,
        80 => SPA_VIDEO_FORMAT_xRGB_210LE,
        81 => SPA_VIDEO_FORMAT_xBGR_210LE,
        82 => SPA_VIDEO_FORMAT_RGBx_102LE,
        83 => SPA_VIDEO_FORMAT_BGRx_102LE,
        84 => SPA_VIDEO_FORMAT_ARGB_210LE,
        85 => SPA_VIDEO_FORMAT_ABGR_210LE,
        86 => SPA_VIDEO_FORMAT_RGBA_102LE,
        87 => SPA_VIDEO_FORMAT_BGRA_102LE,
        _ => throw ArgumentError('Unknown value for spa_video_format: $value'),
      };

  @override
  String toString() {
    if (this == SPA_VIDEO_FORMAT_RGBA_F32)
      return "spa_video_format.SPA_VIDEO_FORMAT_RGBA_F32, spa_video_format.SPA_VIDEO_FORMAT_DSP_F32";
    return super.toString();
  }
}

/// Extra video flags
enum spa_video_flags {
  /// < no flags
  SPA_VIDEO_FLAG_NONE(0),

  /// < a variable fps is selected, fps_n and fps_d
  /// denote the maximum fps of the video
  SPA_VIDEO_FLAG_VARIABLE_FPS(1),

  /// < Each color has been scaled by the alpha value.
  SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA(2);

  final int value;
  const spa_video_flags(this.value);

  static spa_video_flags fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_FLAG_NONE,
        1 => SPA_VIDEO_FLAG_VARIABLE_FPS,
        2 => SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA,
        _ => throw ArgumentError('Unknown value for spa_video_flags: $value'),
      };
}

/// The possible values of the #spa_video_interlace_mode describing the interlace
/// mode of the stream.
enum spa_video_interlace_mode {
  /// < all frames are progressive
  SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE(0),

  /// < 2 fields are interleaved in one video frame.
  /// Extra buffer flags describe the field order.
  SPA_VIDEO_INTERLACE_MODE_INTERLEAVED(1),

  /// < frames contains both interlaced and progressive
  /// video, the buffer flags describe the frame and
  /// fields.
  SPA_VIDEO_INTERLACE_MODE_MIXED(2),

  /// < 2 fields are stored in one buffer, use the
  /// frame ID to get access to the required
  /// field. For multiview (the 'views'
  /// property > 1) the fields of view N can
  /// be found at frame ID (N * 2) and (N *
  /// 2) + 1. Each field has only half the
  /// amount of lines as noted in the height
  /// property. This mode requires multiple
  /// spa_data to describe the fields.
  SPA_VIDEO_INTERLACE_MODE_FIELDS(3);

  final int value;
  const spa_video_interlace_mode(this.value);

  static spa_video_interlace_mode fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE,
        1 => SPA_VIDEO_INTERLACE_MODE_INTERLEAVED,
        2 => SPA_VIDEO_INTERLACE_MODE_MIXED,
        3 => SPA_VIDEO_INTERLACE_MODE_FIELDS,
        _ => throw ArgumentError(
            'Unknown value for spa_video_interlace_mode: $value'),
      };
}

final class spa_rectangle extends ffi.Struct {
  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

/// All possible stereoscopic 3D and multiview representations.
/// In conjunction with \ref spa_video_multiview_flags, describes how
/// multiview content is being transported in the stream.
enum spa_video_multiview_mode {
  /// A special value indicating no multiview information. Used in spa_video_info and other
  /// places to indicate that no specific multiview handling has been requested or provided.
  /// This value is never carried on caps.
  SPA_VIDEO_MULTIVIEW_MODE_NONE(-1),

  /// < All frames are monoscopic
  SPA_VIDEO_MULTIVIEW_MODE_MONO(0),

  /// < All frames represent a left-eye view
  SPA_VIDEO_MULTIVIEW_MODE_LEFT(1),

  /// < All frames represent a right-eye view
  SPA_VIDEO_MULTIVIEW_MODE_RIGHT(2),

  /// < Left and right eye views are provided
  /// in the left and right half of the frame
  /// respectively.
  SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE(3),

  /// < Left and right eye views are provided
  /// in the left and right half of the
  /// frame, but have been sampled using
  /// quincunx method, with half-pixel offset
  /// between the 2 views.
  SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX(4),

  /// < Alternating vertical columns of pixels
  /// represent the left and right eye view
  /// respectively.
  SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED(5),

  /// < Alternating horizontal rows of pixels
  /// represent the left and right eye view
  /// respectively.
  SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED(6),

  /// < The top half of the frame contains the
  /// left eye, and the bottom half the right
  /// eye.
  SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM(7),

  /// < Pixels are arranged with alternating
  /// pixels representing left and right eye
  /// views in a checkerboard fashion.
  SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD(8),

  /// < Left and right eye views are provided
  /// in separate frames alternately.
  SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME(32),

  /// < Multipleindependent views are
  /// provided in separate frames in
  /// sequence. This method only applies to
  /// raw video buffers at the moment.
  /// Specific view identification is via
  /// \ref spa_video_multiview_meta on raw
  /// video buffers.
  SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME(33),

  /// < Multiple views are provided as separate
  /// \ref spa_data framebuffers attached
  /// to each \ref spa_buffer, described
  /// by the \ref spa_video_multiview_meta
  SPA_VIDEO_MULTIVIEW_MODE_SEPARATED(34);

  final int value;
  const spa_video_multiview_mode(this.value);

  static spa_video_multiview_mode fromValue(int value) => switch (value) {
        -1 => SPA_VIDEO_MULTIVIEW_MODE_NONE,
        0 => SPA_VIDEO_MULTIVIEW_MODE_MONO,
        1 => SPA_VIDEO_MULTIVIEW_MODE_LEFT,
        2 => SPA_VIDEO_MULTIVIEW_MODE_RIGHT,
        3 => SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE,
        4 => SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX,
        5 => SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED,
        6 => SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED,
        7 => SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM,
        8 => SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD,
        32 => SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME,
        33 => SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME,
        34 => SPA_VIDEO_MULTIVIEW_MODE_SEPARATED,
        _ => throw ArgumentError(
            'Unknown value for spa_video_multiview_mode: $value'),
      };
}

/// spa_video_multiview_flags are used to indicate extra properties of a
/// stereo/multiview stream beyond the frame layout and buffer mapping
/// that is conveyed in the \ref spa_video_multiview_mode.
enum spa_video_multiview_flags {
  /// < No flags
  SPA_VIDEO_MULTIVIEW_FLAGS_NONE(0),

  /// < For stereo streams, the normal arrangement
  /// of left and right views is reversed
  SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST(1),

  /// < The left view is vertically mirrored
  SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED(2),

  /// < The left view is horizontally mirrored
  SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED(4),

  /// < The right view is vertically mirrored
  SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED(8),

  /// < The right view is horizontally mirrored
  SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED(16),

  /// < For frame-packed multiview
  /// modes, indicates that the individual
  /// views have been encoded with half the true
  /// width or height and should be scaled back
  /// up for display. This flag is used for
  /// overriding input layout interpretation
  /// by adjusting pixel-aspect-ratio.
  /// For side-by-side, column interleaved or
  /// checkerboard packings, the
  /// pixel width will be doubled.
  /// For row interleaved and
  /// top-bottom encodings, pixel height will
  /// be doubled
  SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT(16384),

  /// < The video stream contains both
  /// mono and multiview portions,
  /// signalled on each buffer by the
  /// absence or presence of the
  /// \ref SPA_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW
  /// buffer flag.
  SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO(32768);

  final int value;
  const spa_video_multiview_flags(this.value);

  static spa_video_multiview_flags fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_MULTIVIEW_FLAGS_NONE,
        1 => SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST,
        2 => SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED,
        4 => SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED,
        8 => SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED,
        16 => SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED,
        16384 => SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT,
        32768 => SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO,
        _ => throw ArgumentError(
            'Unknown value for spa_video_multiview_flags: $value'),
      };
}

/// Various Chroma settings.
enum spa_video_chroma_site {
  /// < unknown cositing
  SPA_VIDEO_CHROMA_SITE_UNKNOWN(0),

  /// < no cositing
  SPA_VIDEO_CHROMA_SITE_NONE(1),

  /// < chroma is horizontally cosited
  SPA_VIDEO_CHROMA_SITE_H_COSITED(2),

  /// < chroma is vertically cosited
  SPA_VIDEO_CHROMA_SITE_V_COSITED(4),

  /// < chroma samples are sited on alternate lines
  SPA_VIDEO_CHROMA_SITE_ALT_LINE(8),

  /// chroma samples cosited with luma samples
  SPA_VIDEO_CHROMA_SITE_COSITED(6),
  SPA_VIDEO_CHROMA_SITE_DV(14);

  /// jpeg style cositing, also for mpeg1 and mjpeg
  static const SPA_VIDEO_CHROMA_SITE_JPEG = SPA_VIDEO_CHROMA_SITE_NONE;

  /// mpeg2 style cositing
  static const SPA_VIDEO_CHROMA_SITE_MPEG2 = SPA_VIDEO_CHROMA_SITE_H_COSITED;

  final int value;
  const spa_video_chroma_site(this.value);

  static spa_video_chroma_site fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_CHROMA_SITE_UNKNOWN,
        1 => SPA_VIDEO_CHROMA_SITE_NONE,
        2 => SPA_VIDEO_CHROMA_SITE_H_COSITED,
        4 => SPA_VIDEO_CHROMA_SITE_V_COSITED,
        8 => SPA_VIDEO_CHROMA_SITE_ALT_LINE,
        6 => SPA_VIDEO_CHROMA_SITE_COSITED,
        14 => SPA_VIDEO_CHROMA_SITE_DV,
        _ => throw ArgumentError(
            'Unknown value for spa_video_chroma_site: $value'),
      };

  @override
  String toString() {
    if (this == SPA_VIDEO_CHROMA_SITE_NONE)
      return "spa_video_chroma_site.SPA_VIDEO_CHROMA_SITE_NONE, spa_video_chroma_site.SPA_VIDEO_CHROMA_SITE_JPEG";
    if (this == SPA_VIDEO_CHROMA_SITE_H_COSITED)
      return "spa_video_chroma_site.SPA_VIDEO_CHROMA_SITE_H_COSITED, spa_video_chroma_site.SPA_VIDEO_CHROMA_SITE_MPEG2";
    return super.toString();
  }
}

/// Possible color range values. These constants are defined for 8 bit color
/// values and can be scaled for other bit depths.
enum spa_video_color_range {
  /// < unknown range
  SPA_VIDEO_COLOR_RANGE_UNKNOWN(0),

  /// < [0..255] for 8 bit components
  SPA_VIDEO_COLOR_RANGE_0_255(1),

  /// < [16..235] for 8 bit components. Chroma has
  /// [16..240] range.
  SPA_VIDEO_COLOR_RANGE_16_235(2);

  final int value;
  const spa_video_color_range(this.value);

  static spa_video_color_range fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_COLOR_RANGE_UNKNOWN,
        1 => SPA_VIDEO_COLOR_RANGE_0_255,
        2 => SPA_VIDEO_COLOR_RANGE_16_235,
        _ => throw ArgumentError(
            'Unknown value for spa_video_color_range: $value'),
      };
}

/// The color matrix is used to convert between Y'PbPr and
/// non-linear RGB (R'G'B')
enum spa_video_color_matrix {
  /// < unknown matrix
  SPA_VIDEO_COLOR_MATRIX_UNKNOWN(0),

  /// < identity matrix
  SPA_VIDEO_COLOR_MATRIX_RGB(1),

  /// < FCC color matrix
  SPA_VIDEO_COLOR_MATRIX_FCC(2),

  /// < ITU BT.709 color matrix
  SPA_VIDEO_COLOR_MATRIX_BT709(3),

  /// < ITU BT.601 color matrix
  SPA_VIDEO_COLOR_MATRIX_BT601(4),

  /// < SMTPE  240M color matrix
  SPA_VIDEO_COLOR_MATRIX_SMPTE240M(5),

  /// <  ITU-R BT.2020 color matrix. since 1.6.
  SPA_VIDEO_COLOR_MATRIX_BT2020(6);

  final int value;
  const spa_video_color_matrix(this.value);

  static spa_video_color_matrix fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_COLOR_MATRIX_UNKNOWN,
        1 => SPA_VIDEO_COLOR_MATRIX_RGB,
        2 => SPA_VIDEO_COLOR_MATRIX_FCC,
        3 => SPA_VIDEO_COLOR_MATRIX_BT709,
        4 => SPA_VIDEO_COLOR_MATRIX_BT601,
        5 => SPA_VIDEO_COLOR_MATRIX_SMPTE240M,
        6 => SPA_VIDEO_COLOR_MATRIX_BT2020,
        _ => throw ArgumentError(
            'Unknown value for spa_video_color_matrix: $value'),
      };
}

/// The video transfer function defines the formula for converting between
/// non-linear RGB (R'G'B') and linear RGB
enum spa_video_transfer_function {
  /// < unknown transfer function
  SPA_VIDEO_TRANSFER_UNKNOWN(0),

  /// < linear RGB, gamma 1.0 curve
  SPA_VIDEO_TRANSFER_GAMMA10(1),

  /// < Gamma 1.8 curve
  SPA_VIDEO_TRANSFER_GAMMA18(2),

  /// < Gamma 2.0 curve
  SPA_VIDEO_TRANSFER_GAMMA20(3),

  /// < Gamma 2.2 curve
  SPA_VIDEO_TRANSFER_GAMMA22(4),

  /// < Gamma 2.2 curve with a linear segment in the lower range
  SPA_VIDEO_TRANSFER_BT709(5),

  /// < Gamma 2.2 curve with a linear segment in the lower range
  SPA_VIDEO_TRANSFER_SMPTE240M(6),

  /// < Gamma 2.4 curve with a linear segment in the lower range
  SPA_VIDEO_TRANSFER_SRGB(7),

  /// < Gamma 2.8 curve
  SPA_VIDEO_TRANSFER_GAMMA28(8),

  /// < Logarithmic transfer characteristic 100:1 range
  SPA_VIDEO_TRANSFER_LOG100(9),

  /// < Logarithmic transfer characteristic 316.22777:1 range
  SPA_VIDEO_TRANSFER_LOG316(10),

  /// < Gamma 2.2 curve with a linear segment in the lower
  /// range. Used for BT.2020 with 12 bits per
  /// component. \since 1.6.
  SPA_VIDEO_TRANSFER_BT2020_12(11),

  /// < Gamma 2.19921875. \since 1.8
  SPA_VIDEO_TRANSFER_ADOBERGB(12);

  final int value;
  const spa_video_transfer_function(this.value);

  static spa_video_transfer_function fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_TRANSFER_UNKNOWN,
        1 => SPA_VIDEO_TRANSFER_GAMMA10,
        2 => SPA_VIDEO_TRANSFER_GAMMA18,
        3 => SPA_VIDEO_TRANSFER_GAMMA20,
        4 => SPA_VIDEO_TRANSFER_GAMMA22,
        5 => SPA_VIDEO_TRANSFER_BT709,
        6 => SPA_VIDEO_TRANSFER_SMPTE240M,
        7 => SPA_VIDEO_TRANSFER_SRGB,
        8 => SPA_VIDEO_TRANSFER_GAMMA28,
        9 => SPA_VIDEO_TRANSFER_LOG100,
        10 => SPA_VIDEO_TRANSFER_LOG316,
        11 => SPA_VIDEO_TRANSFER_BT2020_12,
        12 => SPA_VIDEO_TRANSFER_ADOBERGB,
        _ => throw ArgumentError(
            'Unknown value for spa_video_transfer_function: $value'),
      };
}

/// The color primaries define the how to transform linear RGB values to and from
/// the CIE XYZ colorspace.
enum spa_video_color_primaries {
  /// < unknown color primaries
  SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN(0),

  /// < BT709 primaries
  SPA_VIDEO_COLOR_PRIMARIES_BT709(1),

  /// < BT470M primaries
  SPA_VIDEO_COLOR_PRIMARIES_BT470M(2),

  /// < BT470BG primaries
  SPA_VIDEO_COLOR_PRIMARIES_BT470BG(3),

  /// < SMPTE170M primaries
  SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M(4),

  /// < SMPTE240M primaries
  SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M(5),

  /// < Generic film
  SPA_VIDEO_COLOR_PRIMARIES_FILM(6),

  /// < BT2020 primaries. \since 1.6.
  SPA_VIDEO_COLOR_PRIMARIES_BT2020(7),

  /// < Adobe RGB primaries. \since 1.8
  SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB(8);

  final int value;
  const spa_video_color_primaries(this.value);

  static spa_video_color_primaries fromValue(int value) => switch (value) {
        0 => SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN,
        1 => SPA_VIDEO_COLOR_PRIMARIES_BT709,
        2 => SPA_VIDEO_COLOR_PRIMARIES_BT470M,
        3 => SPA_VIDEO_COLOR_PRIMARIES_BT470BG,
        4 => SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M,
        5 => SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M,
        6 => SPA_VIDEO_COLOR_PRIMARIES_FILM,
        7 => SPA_VIDEO_COLOR_PRIMARIES_BT2020,
        8 => SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB,
        _ => throw ArgumentError(
            'Unknown value for spa_video_color_primaries: $value'),
      };
}

///
final class spa_video_info_raw extends ffi.Struct {
  /// < the format
  @ffi.UnsignedInt()
  external int formatAsInt;

  spa_video_format get format => spa_video_format.fromValue(formatAsInt);

  /// < format modifier
  /// only used with DMA-BUF
  @ffi.Int64()
  external int modifier;

  /// < the frame size of the video
  external spa_rectangle size;

  /// < the framerate of the video, 0/1 means variable rate
  external spa_fraction framerate;

  /// < the maximum framerate of the video. This is only valid when
  /// \ref framerate is 0/1
  external spa_fraction max_framerate;

  /// < the number of views in this video
  @ffi.Uint32()
  external int views;

  /// < the interlace mode
  @ffi.UnsignedInt()
  external int interlace_modeAsInt;

  spa_video_interlace_mode get interlace_mode =>
      spa_video_interlace_mode.fromValue(interlace_modeAsInt);

  /// < the pixel aspect ratio
  external spa_fraction pixel_aspect_ratio;

  /// < multiview mode
  @ffi.Int()
  external int multiview_modeAsInt;

  spa_video_multiview_mode get multiview_mode =>
      spa_video_multiview_mode.fromValue(multiview_modeAsInt);

  /// < multiview flags
  @ffi.UnsignedInt()
  external int multiview_flagsAsInt;

  spa_video_multiview_flags get multiview_flags =>
      spa_video_multiview_flags.fromValue(multiview_flagsAsInt);

  /// < the chroma siting
  @ffi.UnsignedInt()
  external int chroma_siteAsInt;

  spa_video_chroma_site get chroma_site =>
      spa_video_chroma_site.fromValue(chroma_siteAsInt);

  /// < the color range. This is the valid range for the samples.
  /// It is used to convert the samples to Y'PbPr values.
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  spa_video_color_range get color_range =>
      spa_video_color_range.fromValue(color_rangeAsInt);

  /// < the color matrix. Used to convert between Y'PbPr and
  /// non-linear RGB (R'G'B')
  @ffi.UnsignedInt()
  external int color_matrixAsInt;

  spa_video_color_matrix get color_matrix =>
      spa_video_color_matrix.fromValue(color_matrixAsInt);

  /// < the transfer function. used to convert between R'G'B' and RGB
  @ffi.UnsignedInt()
  external int transfer_functionAsInt;

  spa_video_transfer_function get transfer_function =>
      spa_video_transfer_function.fromValue(transfer_functionAsInt);

  /// < color primaries. used to convert between R'G'B' and CIE XYZ
  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  spa_video_color_primaries get color_primaries =>
      spa_video_color_primaries.fromValue(color_primariesAsInt);
}

final class spa_video_info_dsp extends ffi.Struct {
  @ffi.UnsignedInt()
  external int formatAsInt;

  spa_video_format get format => spa_video_format.fromValue(formatAsInt);

  @ffi.Int64()
  external int modifier;
}

typedef gpointer = ffi.Pointer<ffi.Void>;
typedef GHook = _GHook;
typedef guint = ffi.UnsignedInt;
typedef Dartguint = int;
typedef gulong = ffi.UnsignedLong;
typedef Dartgulong = int;
typedef GDestroyNotifyFunction = ffi.Void Function(gpointer data);
typedef DartGDestroyNotifyFunction = void Function(gpointer data);
typedef GDestroyNotify
    = ffi.Pointer<ffi.NativeFunction<GDestroyNotifyFunction>>;

final class _GHook extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GHook> next;

  external ffi.Pointer<GHook> prev;

  @guint()
  external int ref_count;

  @gulong()
  external int hook_id;

  @guint()
  external int flags;

  external gpointer func;

  external GDestroyNotify destroy;
}

final class _GHookList extends ffi.Opaque {}

typedef GHookList = _GHookList;
typedef gint = ffi.Int;
typedef Dartgint = int;
typedef GHookCompareFuncFunction = gint Function(
    ffi.Pointer<GHook> new_hook, ffi.Pointer<GHook> sibling);
typedef DartGHookCompareFuncFunction = Dartgint Function(
    ffi.Pointer<GHook> new_hook, ffi.Pointer<GHook> sibling);
typedef GHookCompareFunc
    = ffi.Pointer<ffi.NativeFunction<GHookCompareFuncFunction>>;
typedef gboolean = gint;
typedef GHookFindFuncFunction = gboolean Function(
    ffi.Pointer<GHook> hook, gpointer data);
typedef DartGHookFindFuncFunction = Dartgint Function(
    ffi.Pointer<GHook> hook, gpointer data);
typedef GHookFindFunc = ffi.Pointer<ffi.NativeFunction<GHookFindFuncFunction>>;
typedef GHookMarshallerFunction = ffi.Void Function(
    ffi.Pointer<GHook> hook, gpointer marshal_data);
typedef DartGHookMarshallerFunction = void Function(
    ffi.Pointer<GHook> hook, gpointer marshal_data);
typedef GHookMarshaller
    = ffi.Pointer<ffi.NativeFunction<GHookMarshallerFunction>>;
typedef GHookCheckMarshallerFunction = gboolean Function(
    ffi.Pointer<GHook> hook, gpointer marshal_data);
typedef DartGHookCheckMarshallerFunction = Dartgint Function(
    ffi.Pointer<GHook> hook, gpointer marshal_data);
typedef GHookCheckMarshaller
    = ffi.Pointer<ffi.NativeFunction<GHookCheckMarshallerFunction>>;
typedef GHookFuncFunction = ffi.Void Function(gpointer data);
typedef DartGHookFuncFunction = void Function(gpointer data);
typedef GHookFunc = ffi.Pointer<ffi.NativeFunction<GHookFuncFunction>>;
typedef GHookCheckFuncFunction = gboolean Function(gpointer data);
typedef DartGHookCheckFuncFunction = Dartgint Function(gpointer data);
typedef GHookCheckFunc
    = ffi.Pointer<ffi.NativeFunction<GHookCheckFuncFunction>>;
typedef GHookFinalizeFuncFunction = ffi.Void Function(
    ffi.Pointer<GHookList> hook_list, ffi.Pointer<GHook> hook);
typedef DartGHookFinalizeFuncFunction = void Function(
    ffi.Pointer<GHookList> hook_list, ffi.Pointer<GHook> hook);
typedef GHookFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GHookFinalizeFuncFunction>>;

enum GHookFlagMask {
  G_HOOK_FLAG_ACTIVE(1),
  G_HOOK_FLAG_IN_CALL(2),
  G_HOOK_FLAG_MASK(15);

  final int value;
  const GHookFlagMask(this.value);

  static GHookFlagMask fromValue(int value) => switch (value) {
        1 => G_HOOK_FLAG_ACTIVE,
        2 => G_HOOK_FLAG_IN_CALL,
        15 => G_HOOK_FLAG_MASK,
        _ => throw ArgumentError('Unknown value for GHookFlagMask: $value'),
      };
}

typedef gsize = ffi.UnsignedLong;
typedef Dartgsize = int;
typedef GType = gsize;

/// GTypeInterface:
///
/// An opaque structure used as the base of all interface types.
final class _GTypeInterface extends ffi.Struct {
  @GType()
  external int g_type;

  @GType()
  external int g_instance_type;
}

typedef GTypeInterface = _GTypeInterface;

final class _GTypePlugin extends ffi.Opaque {}

typedef GTypePlugin = _GTypePlugin;
typedef GTypePluginUseFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin);
typedef DartGTypePluginUseFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin);

/// GTypePluginUse:
/// @plugin: the #GTypePlugin whose use count should be increased
///
/// The type of the @use_plugin function of #GTypePluginClass, which gets called
/// to increase the use count of @plugin.
typedef GTypePluginUse
    = ffi.Pointer<ffi.NativeFunction<GTypePluginUseFunction>>;
typedef GTypePluginUnuseFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin);
typedef DartGTypePluginUnuseFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin);

/// GTypePluginUnuse:
/// @plugin: the #GTypePlugin whose use count should be decreased
///
/// The type of the @unuse_plugin function of #GTypePluginClass.
typedef GTypePluginUnuse
    = ffi.Pointer<ffi.NativeFunction<GTypePluginUnuseFunction>>;
typedef guint16 = ffi.UnsignedShort;
typedef Dartguint16 = int;
typedef GBaseInitFuncFunction = ffi.Void Function(gpointer g_class);
typedef DartGBaseInitFuncFunction = void Function(gpointer g_class);

/// GBaseInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize
///
/// A callback function used by the type system to do base initialization
/// of the class structures of derived types.
///
/// This function is called as part of the initialization process of all derived
/// classes and should reallocate or reset all dynamic class members copied over
/// from the parent class.
///
/// For example, class members (such as strings) that are not sufficiently
/// handled by a plain memory copy of the parent class into the derived class
/// have to be altered. See GClassInitFunc() for a discussion of the class
/// initialization process.
typedef GBaseInitFunc = ffi.Pointer<ffi.NativeFunction<GBaseInitFuncFunction>>;
typedef GBaseFinalizeFuncFunction = ffi.Void Function(gpointer g_class);
typedef DartGBaseFinalizeFuncFunction = void Function(gpointer g_class);

/// GBaseFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
///
/// A callback function used by the type system to finalize those portions
/// of a derived types class structure that were setup from the corresponding
/// GBaseInitFunc() function.
///
/// Class finalization basically works the inverse way in which class
/// initialization is performed.
///
/// See GClassInitFunc() for a discussion of the class initialization process.
typedef GBaseFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GBaseFinalizeFuncFunction>>;
typedef GClassInitFuncFunction = ffi.Void Function(
    gpointer g_class, gpointer class_data);
typedef DartGClassInitFuncFunction = void Function(
    gpointer g_class, gpointer class_data);

/// GClassInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.
/// @class_data: The @class_data member supplied via the #GTypeInfo structure.
///
/// A callback function used by the type system to initialize the class
/// of a specific type.
///
/// This function should initialize all static class members.
///
/// The initialization process of a class involves:
///
/// - Copying common members from the parent class over to the
/// derived class structure.
/// - Zero initialization of the remaining members not copied
/// over from the parent class.
/// - Invocation of the GBaseInitFunc() initializers of all parent
/// types and the class' type.
/// - Invocation of the class' GClassInitFunc() initializer.
///
/// Since derived classes are partially initialized through a memory copy
/// of the parent class, the general rule is that GBaseInitFunc() and
/// GBaseFinalizeFunc() should take care of necessary reinitialization
/// and release of those class members that were introduced by the type
/// that specified these GBaseInitFunc()/GBaseFinalizeFunc().
/// GClassInitFunc() should only care about initializing static
/// class members, while dynamic class members (such as allocated strings
/// or reference counted resources) are better handled by a GBaseInitFunc()
/// for this type, so proper initialization of the dynamic class members
/// is performed for class initialization of derived types as well.
///
/// An example may help to correspond the intend of the different class
/// initializers:
///
/// |[<!-- language="C" -->
/// typedef struct {
/// GObjectClass parent_class;
/// gint         static_integer;
/// gchar       *dynamic_string;
/// } TypeAClass;
/// static void
/// type_a_base_class_init (TypeAClass *class)
/// {
/// class->dynamic_string = g_strdup ("some string");
/// }
/// static void
/// type_a_base_class_finalize (TypeAClass *class)
/// {
/// g_free (class->dynamic_string);
/// }
/// static void
/// type_a_class_init (TypeAClass *class)
/// {
/// class->static_integer = 42;
/// }
///
/// typedef struct {
/// TypeAClass   parent_class;
/// gfloat       static_float;
/// GString     *dynamic_gstring;
/// } TypeBClass;
/// static void
/// type_b_base_class_init (TypeBClass *class)
/// {
/// class->dynamic_gstring = g_string_new ("some other string");
/// }
/// static void
/// type_b_base_class_finalize (TypeBClass *class)
/// {
/// g_string_free (class->dynamic_gstring);
/// }
/// static void
/// type_b_class_init (TypeBClass *class)
/// {
/// class->static_float = 3.14159265358979323846;
/// }
/// ]|
///
/// Initialization of TypeBClass will first cause initialization of
/// TypeAClass (derived classes reference their parent classes, see
/// g_type_class_ref() on this).
///
/// Initialization of TypeAClass roughly involves zero-initializing its fields,
/// then calling its GBaseInitFunc() type_a_base_class_init() to allocate
/// its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
/// type_a_class_init() to initialize its static members (static_integer).
/// The first step in the initialization process of TypeBClass is then
/// a plain memory copy of the contents of TypeAClass into TypeBClass and
/// zero-initialization of the remaining fields in TypeBClass.
/// The dynamic members of TypeAClass within TypeBClass now need
/// reinitialization which is performed by calling type_a_base_class_init()
/// with an argument of TypeBClass.
///
/// After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
/// is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
/// and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
/// is called to complete the initialization process with the static members
/// (static_float).
///
/// Corresponding finalization counter parts to the GBaseInitFunc() functions
/// have to be provided to release allocated resources at class finalization
/// time.
typedef GClassInitFunc
    = ffi.Pointer<ffi.NativeFunction<GClassInitFuncFunction>>;
typedef GClassFinalizeFuncFunction = ffi.Void Function(
    gpointer g_class, gpointer class_data);
typedef DartGClassFinalizeFuncFunction = void Function(
    gpointer g_class, gpointer class_data);

/// GClassFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
/// @class_data: The @class_data member supplied via the #GTypeInfo structure
///
/// A callback function used by the type system to finalize a class.
///
/// This function is rarely needed, as dynamically allocated class resources
/// should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
///
/// Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
/// structure of a static type is invalid, because classes of static types
/// will never be finalized (they are artificially kept alive when their
/// reference count drops to zero).
typedef GClassFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GClassFinalizeFuncFunction>>;
typedef gconstpointer = ffi.Pointer<ffi.Void>;

/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
final class _GTypeClass extends ffi.Struct {
  @GType()
  external int g_type;
}

typedef GTypeClass = _GTypeClass;

/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
final class _GTypeInstance extends ffi.Struct {
  external ffi.Pointer<GTypeClass> g_class;
}

typedef GTypeInstance = _GTypeInstance;
typedef GInstanceInitFuncFunction = ffi.Void Function(
    ffi.Pointer<GTypeInstance> instance, gpointer g_class);
typedef DartGInstanceInitFuncFunction = void Function(
    ffi.Pointer<GTypeInstance> instance, gpointer g_class);

/// GInstanceInitFunc:
/// @instance: The instance to initialize
/// @g_class: (type GObject.TypeClass): The class of the type the instance is
/// created for
///
/// A callback function used by the type system to initialize a new
/// instance of a type.
///
/// This function initializes all instance members and allocates any resources
/// required by it.
///
/// Initialization of a derived instance involves calling all its parent
/// types instance initializers, so the class member of the instance
/// is altered during its initialization to always point to the class that
/// belongs to the type the current initializer was introduced for.
///
/// The extended members of @instance are guaranteed to have been filled with
/// zeros before this function is called.
typedef GInstanceInitFunc
    = ffi.Pointer<ffi.NativeFunction<GInstanceInitFuncFunction>>;
typedef glong = ffi.Long;
typedef Dartglong = int;
typedef gint64 = ffi.Long;
typedef Dartgint64 = int;
typedef guint64 = ffi.UnsignedLong;
typedef Dartguint64 = int;
typedef gfloat = ffi.Float;
typedef Dartgfloat = double;
typedef gdouble = ffi.Double;
typedef Dartgdouble = double;

final class UnnamedUnion2 extends ffi.Union {
  @gint()
  external int v_int;

  @guint()
  external int v_uint;

  @glong()
  external int v_long;

  @gulong()
  external int v_ulong;

  @gint64()
  external int v_int64;

  @guint64()
  external int v_uint64;

  @gfloat()
  external double v_float;

  @gdouble()
  external double v_double;

  external gpointer v_pointer;
}

/// GValue:
///
/// An opaque structure used to hold different types of values.
///
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
///
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
final class _GValue extends ffi.Struct {
  @GType()
  external int g_type;

  @ffi.Array.multi([2])
  external ffi.Array<UnnamedUnion2> data;
}

typedef GValue = _GValue;
typedef gchar = ffi.Char;
typedef Dartgchar = int;

final class _GTypeCValue extends ffi.Opaque {}

typedef GTypeCValue = _GTypeCValue;

/// GTypeValueTable:
/// @value_init: Default initialize @values contents by poking values
/// directly into the value->data array. The data array of
/// the #GValue passed into this function was zero-filled
/// with `memset()`, so no care has to be taken to free any
/// old contents. E.g. for the implementation of a string
/// value that may never be %NULL, the implementation might
/// look like:
/// |[<!-- language="C" -->
/// value->data[0].v_pointer = g_strdup ("");
/// ]|
/// @value_free: Free any old contents that might be left in the
/// data array of the passed in @value. No resources may
/// remain allocated through the #GValue contents after
/// this function returns. E.g. for our above string type:
/// |[<!-- language="C" -->
/// // only free strings without a specific flag for static storage
/// if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))
/// g_free (value->data[0].v_pointer);
/// ]|
/// @value_copy: @dest_value is a #GValue with zero-filled data section
/// and @src_value is a properly setup #GValue of same or
/// derived type.
/// The purpose of this function is to copy the contents of
/// @src_value into @dest_value in a way, that even after
/// @src_value has been freed, the contents of @dest_value
/// remain valid. String type example:
/// |[<!-- language="C" -->
/// dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
/// ]|
/// @value_peek_pointer: If the value contents fit into a pointer, such as objects
/// or strings, return this pointer, so the caller can peek at
/// the current contents. To extend on our above string example:
/// |[<!-- language="C" -->
/// return value->data[0].v_pointer;
/// ]|
/// @collect_format: A string format describing how to collect the contents of
/// this value bit-by-bit. Each character in the format represents
/// an argument to be collected, and the characters themselves indicate
/// the type of the argument. Currently supported arguments are:
/// - 'i' - Integers. passed as collect_values[].v_int.
/// - 'l' - Longs. passed as collect_values[].v_long.
/// - 'd' - Doubles. passed as collect_values[].v_double.
/// - 'p' - Pointers. passed as collect_values[].v_pointer.
/// It should be noted that for variable argument list construction,
/// ANSI C promotes every type smaller than an integer to an int, and
/// floats to doubles. So for collection of short int or char, 'i'
/// needs to be used, and for collection of floats 'd'.
/// @collect_value: The collect_value() function is responsible for converting the
/// values collected from a variable argument list into contents
/// suitable for storage in a GValue. This function should setup
/// @value similar to value_init(); e.g. for a string value that
/// does not allow %NULL pointers, it needs to either spew an error,
/// or do an implicit conversion by storing an empty string.
/// The @value passed in to this function has a zero-filled data
/// array, so just like for value_init() it is guaranteed to not
/// contain any old contents that might need freeing.
/// @n_collect_values is exactly the string length of @collect_format,
/// and @collect_values is an array of unions #GTypeCValue with
/// length @n_collect_values, containing the collected values
/// according to @collect_format.
/// @collect_flags is an argument provided as a hint by the caller.
/// It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,
/// that the collected value contents may be considered "static"
/// for the duration of the @value lifetime.
/// Thus an extra copy of the contents stored in @collect_values is
/// not required for assignment to @value.
/// For our above string example, we continue with:
/// |[<!-- language="C" -->
/// if (!collect_values[0].v_pointer)
/// value->data[0].v_pointer = g_strdup ("");
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// {
/// value->data[0].v_pointer = collect_values[0].v_pointer;
/// // keep a flag for the value_free() implementation to not free this string
/// value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
/// }
/// else
/// value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
/// return NULL;
/// ]|
/// It should be noted, that it is generally a bad idea to follow the
/// %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
/// reentrancy requirements and reference count assertions performed
/// by the signal emission code, reference counts should always be
/// incremented for reference counted contents stored in the value->data
/// array.  To deviate from our string example for a moment, and taking
/// a look at an exemplary implementation for collect_value() of
/// #GObject:
/// |[<!-- language="C" -->
/// GObject *object = G_OBJECT (collect_values[0].v_pointer);
/// g_return_val_if_fail (object != NULL,
/// g_strdup_printf ("Object passed as invalid NULL pointer"));
/// // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
/// value->data[0].v_pointer = g_object_ref (object);
/// return NULL;
/// ]|
/// The reference count for valid objects is always incremented,
/// regardless of @collect_flags. For invalid objects, the example
/// returns a newly allocated string without altering @value.
/// Upon success, collect_value() needs to return %NULL. If, however,
/// an error condition occurred, collect_value() may spew an
/// error by returning a newly allocated non-%NULL string, giving
/// a suitable description of the error condition.
/// The calling code makes no assumptions about the @value
/// contents being valid upon error returns, @value
/// is simply thrown away without further freeing. As such, it is
/// a good idea to not allocate #GValue contents, prior to returning
/// an error, however, collect_values() is not obliged to return
/// a correctly setup @value for error returns, simply because
/// any non-%NULL return is considered a fatal condition so further
/// program behaviour is undefined.
/// @lcopy_format: Format description of the arguments to collect for @lcopy_value,
/// analogous to @collect_format. Usually, @lcopy_format string consists
/// only of 'p's to provide lcopy_value() with pointers to storage locations.
/// @lcopy_value: This function is responsible for storing the @value contents into
/// arguments passed through a variable argument list which got
/// collected into @collect_values according to @lcopy_format.
/// @n_collect_values equals the string length of @lcopy_format,
/// and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.
/// In contrast to collect_value(), lcopy_value() is obliged to
/// always properly support %G_VALUE_NOCOPY_CONTENTS.
/// Similar to collect_value() the function may prematurely abort
/// by returning a newly allocated string describing an error condition.
/// To complete the string example:
/// |[<!-- language="C" -->
/// gchar **string_p = collect_values[0].v_pointer;
/// g_return_val_if_fail (string_p != NULL,
/// g_strdup_printf ("string location passed as NULL"));
/// if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// *string_p = value->data[0].v_pointer;
/// else
/// *string_p = g_strdup (value->data[0].v_pointer);
/// ]|
/// And an illustrative version of lcopy_value() for
/// reference-counted types:
/// |[<!-- language="C" -->
/// GObject **object_p = collect_values[0].v_pointer;
/// g_return_val_if_fail (object_p != NULL,
/// g_strdup_printf ("object location passed as NULL"));
/// if (!value->data[0].v_pointer)
/// *object_p = NULL;
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour
/// *object_p = value->data[0].v_pointer;
/// else
/// *object_p = g_object_ref (value->data[0].v_pointer);
/// return NULL;
/// ]|
///
/// The #GTypeValueTable provides the functions required by the #GValue
/// implementation, to serve as a container for values of a type.
final class _GTypeValueTable extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue> value)>>
      value_init;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue> value)>>
      value_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue> src_value,
              ffi.Pointer<GValue> dest_value)>> value_copy;

  external ffi
      .Pointer<ffi.NativeFunction<gpointer Function(ffi.Pointer<GValue> value)>>
      value_peek_pointer;

  external ffi.Pointer<gchar> collect_format;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GValue> value,
              guint n_collect_values,
              ffi.Pointer<GTypeCValue> collect_values,
              guint collect_flags)>> collect_value;

  external ffi.Pointer<gchar> lcopy_format;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<gchar> Function(
              ffi.Pointer<GValue> value,
              guint n_collect_values,
              ffi.Pointer<GTypeCValue> collect_values,
              guint collect_flags)>> lcopy_value;
}

typedef GTypeValueTable = _GTypeValueTable;

/// GTypeInfo:
/// @class_size: Size of the class structure (required for interface, classed and instantiatable types)
/// @base_init: Location of the base initialization function (optional)
/// @base_finalize: Location of the base finalization function (optional)
/// @class_init: Location of the class initialization function for
/// classed and instantiatable types. Location of the default vtable
/// inititalization function for interface types. (optional) This function
/// is used both to fill in virtual functions in the class or default vtable,
/// and to do type-specific setup such as registering signals and object
/// properties.
/// @class_finalize: Location of the class finalization function for
/// classed and instantiatable types. Location of the default vtable
/// finalization function for interface types. (optional)
/// @class_data: User-supplied data passed to the class init/finalize functions
/// @instance_size: Size of the instance (object) structure (required for instantiatable types only)
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional, for instantiatable types only)
/// @value_table: A #GTypeValueTable function table for generic handling of GValues
/// of this type (usually only useful for fundamental types)
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a type's class and
/// its instances.
///
/// The initialized structure is passed to the g_type_register_static() function
/// (or is copied into the provided #GTypeInfo structure in the
/// g_type_plugin_complete_type_info()). The type system will perform a deep
/// copy of this structure, so its memory does not need to be persistent
/// across invocation of g_type_register_static().
final class _GTypeInfo extends ffi.Struct {
  @guint16()
  external int class_size;

  external GBaseInitFunc base_init;

  external GBaseFinalizeFunc base_finalize;

  external GClassInitFunc class_init;

  external GClassFinalizeFunc class_finalize;

  external gconstpointer class_data;

  @guint16()
  external int instance_size;

  @guint16()
  external int n_preallocs;

  external GInstanceInitFunc instance_init;

  external ffi.Pointer<GTypeValueTable> value_table;
}

typedef GTypeInfo = _GTypeInfo;
typedef GTypePluginCompleteTypeInfoFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin,
    GType g_type,
    ffi.Pointer<GTypeInfo> info,
    ffi.Pointer<GTypeValueTable> value_table);
typedef DartGTypePluginCompleteTypeInfoFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin,
    Dartgsize g_type,
    ffi.Pointer<GTypeInfo> info,
    ffi.Pointer<GTypeValueTable> value_table);

/// GTypePluginCompleteTypeInfo:
/// @plugin: the #GTypePlugin
/// @g_type: the #GType whose info is completed
/// @info: the #GTypeInfo struct to fill in
/// @value_table: the #GTypeValueTable to fill in
///
/// The type of the @complete_type_info function of #GTypePluginClass.
typedef GTypePluginCompleteTypeInfo
    = ffi.Pointer<ffi.NativeFunction<GTypePluginCompleteTypeInfoFunction>>;
typedef GInterfaceInitFuncFunction = ffi.Void Function(
    gpointer g_iface, gpointer iface_data);
typedef DartGInterfaceInitFuncFunction = void Function(
    gpointer g_iface, gpointer iface_data);

/// GInterfaceInitFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to initialize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to initialize a new
/// interface.
///
/// This function should initialize all internal data and* allocate any
/// resources required by the interface.
///
/// The members of @iface_data are guaranteed to have been filled with
/// zeros before this function is called.
typedef GInterfaceInitFunc
    = ffi.Pointer<ffi.NativeFunction<GInterfaceInitFuncFunction>>;
typedef GInterfaceFinalizeFuncFunction = ffi.Void Function(
    gpointer g_iface, gpointer iface_data);
typedef DartGInterfaceFinalizeFuncFunction = void Function(
    gpointer g_iface, gpointer iface_data);

/// GInterfaceFinalizeFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to finalize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to finalize an interface.
///
/// This function should destroy any internal data and release any resources
/// allocated by the corresponding GInterfaceInitFunc() function.
typedef GInterfaceFinalizeFunc
    = ffi.Pointer<ffi.NativeFunction<GInterfaceFinalizeFuncFunction>>;

/// GInterfaceInfo:
/// @interface_init: location of the interface initialization function
/// @interface_finalize: location of the interface finalization function
/// @interface_data: user-supplied data passed to the interface init/finalize functions
///
/// A structure that provides information to the type system which is
/// used specifically for managing interface types.
final class _GInterfaceInfo extends ffi.Struct {
  external GInterfaceInitFunc interface_init;

  external GInterfaceFinalizeFunc interface_finalize;

  external gpointer interface_data;
}

typedef GInterfaceInfo = _GInterfaceInfo;
typedef GTypePluginCompleteInterfaceInfoFunction = ffi.Void Function(
    ffi.Pointer<GTypePlugin> plugin,
    GType instance_type,
    GType interface_type,
    ffi.Pointer<GInterfaceInfo> info);
typedef DartGTypePluginCompleteInterfaceInfoFunction = void Function(
    ffi.Pointer<GTypePlugin> plugin,
    Dartgsize instance_type,
    Dartgsize interface_type,
    ffi.Pointer<GInterfaceInfo> info);

/// GTypePluginCompleteInterfaceInfo:
/// @plugin: the #GTypePlugin
/// @instance_type: the #GType of an instantiatable type to which the interface
/// is added
/// @interface_type: the #GType of the interface whose info is completed
/// @info: the #GInterfaceInfo to fill in
///
/// The type of the @complete_interface_info function of #GTypePluginClass.
typedef GTypePluginCompleteInterfaceInfo
    = ffi.Pointer<ffi.NativeFunction<GTypePluginCompleteInterfaceInfoFunction>>;

/// GTypePlugin:
///
/// The GTypePlugin typedef is used as a placeholder
/// for objects that implement the GTypePlugin interface.
/// /
/// /**
/// GTypePluginClass:
/// @use_plugin: Increases the use count of the plugin.
/// @unuse_plugin: Decreases the use count of the plugin.
/// @complete_type_info: Fills in the #GTypeInfo and
/// #GTypeValueTable structs for the type. The structs are initialized
/// with `memset(s, 0, sizeof (s))` before calling this function.
/// @complete_interface_info: Fills in missing parts of the #GInterfaceInfo
/// for the interface. The structs is initialized with
/// `memset(s, 0, sizeof (s))` before calling this function.
///
/// The #GTypePlugin interface is used by the type system in order to handle
/// the lifecycle of dynamically loaded types.
final class _GTypePluginClass extends ffi.Struct {
  external GTypeInterface base_iface;

  external GTypePluginUse use_plugin;

  external GTypePluginUnuse unuse_plugin;

  external GTypePluginCompleteTypeInfo complete_type_info;

  external GTypePluginCompleteInterfaceInfo complete_interface_info;
}

typedef GTypePluginClass = _GTypePluginClass;

final class _GAsyncResult extends ffi.Opaque {}

typedef GAsyncResult = _GAsyncResult;

final class _GData extends ffi.Opaque {}

typedef GData = _GData;

/// GObject:
///
/// The base object type.
///
/// All the fields in the `GObject` structure are private to the implementation
/// and should never be accessed directly.
///
/// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
/// alignment of the largest basic GLib type (typically this is #guint64 or
/// #gdouble). If you need larger alignment for an element in a #GObject, you
/// should allocate it on the heap (aligned), or arrange for your #GObject to be
/// appropriately padded. This guarantee applies to the #GObject (or derived)
/// struct, the #GObjectClass (or derived) struct, and any private data allocated
/// by G_ADD_PRIVATE().
final class _GObject extends ffi.Struct {
  external GTypeInstance g_type_instance;

  @guint()
  external int ref_count;

  external ffi.Pointer<GData> qdata;
}

typedef GObject = _GObject;

/// GAsyncResultIface:
/// @g_iface: The parent interface.
/// @get_user_data: Gets the user data passed to the callback.
/// @get_source_object: Gets the source object that issued the asynchronous operation.
/// @is_tagged: Checks if a result is tagged with a particular source.
///
/// Interface definition for #GAsyncResult.
final class _GAsyncResultIface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<gpointer Function(ffi.Pointer<GAsyncResult> res)>>
      get_user_data;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GObject> Function(ffi.Pointer<GAsyncResult> res)>>
      get_source_object;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GAsyncResult> res, gpointer source_tag)>> is_tagged;
}

/// GAsyncResult:
///
/// Holds results information for an asynchronous operation,
/// usually passed directly to an asynchronous _finish() operation.
typedef GAsyncResultIface = _GAsyncResultIface;
typedef guint32 = ffi.UnsignedInt;
typedef Dartguint32 = int;
typedef GQuark = guint32;

final class _GError extends ffi.Struct {
  @GQuark()
  external int domain;

  @gint()
  external int code;

  external ffi.Pointer<gchar> message;
}

/// GError:
/// @domain: error domain, e.g. %G_FILE_ERROR
/// @code: error code, e.g. %G_FILE_ERROR_NOENT
/// @message: human-readable informative error message
///
/// The `GError` structure contains information about
/// an error that has occurred.
typedef GError = _GError;
typedef GSList = _GSList;

final class _GSList extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GSList> next;
}

typedef GSList$1 = _GSList;

/// GParamFlags:
/// @G_PARAM_READABLE: the parameter is readable
/// @G_PARAM_WRITABLE: the parameter is writable
/// @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
/// @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
/// @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
/// @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
/// strict validation is not required
/// @G_PARAM_STATIC_NAME: the string used as name when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_NICK: the string used as nick when constructing the
/// parameter is guaranteed to remain valid and
/// unmmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
/// property will not automatically result in a "notify" signal being
/// emitted: the implementation must call g_object_notify() themselves
/// in case the property actually changes.  Since: 2.42.
/// @G_PARAM_PRIVATE: internal
/// @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
/// in a future version. A warning will be generated if it is used
/// while running with G_ENABLE_DIAGNOSTIC=1.
/// Since 2.26
///
/// Through the #GParamFlags flag values, certain aspects of parameters
/// can be configured.
///
/// See also: %G_PARAM_STATIC_STRINGS
enum GParamFlags {
  G_PARAM_READABLE(1),
  G_PARAM_WRITABLE(2),
  G_PARAM_READWRITE(3),
  G_PARAM_CONSTRUCT(4),
  G_PARAM_CONSTRUCT_ONLY(8),
  G_PARAM_LAX_VALIDATION(16),
  G_PARAM_STATIC_NAME(32),
  G_PARAM_STATIC_NICK(64),
  G_PARAM_STATIC_BLURB(128),
  G_PARAM_EXPLICIT_NOTIFY(1073741824),
  G_PARAM_DEPRECATED(-2147483648);

  static const G_PARAM_PRIVATE = G_PARAM_STATIC_NAME;

  final int value;
  const GParamFlags(this.value);

  static GParamFlags fromValue(int value) => switch (value) {
        1 => G_PARAM_READABLE,
        2 => G_PARAM_WRITABLE,
        3 => G_PARAM_READWRITE,
        4 => G_PARAM_CONSTRUCT,
        8 => G_PARAM_CONSTRUCT_ONLY,
        16 => G_PARAM_LAX_VALIDATION,
        32 => G_PARAM_STATIC_NAME,
        64 => G_PARAM_STATIC_NICK,
        128 => G_PARAM_STATIC_BLURB,
        1073741824 => G_PARAM_EXPLICIT_NOTIFY,
        -2147483648 => G_PARAM_DEPRECATED,
        _ => throw ArgumentError('Unknown value for GParamFlags: $value'),
      };

  @override
  String toString() {
    if (this == G_PARAM_STATIC_NAME)
      return "GParamFlags.G_PARAM_STATIC_NAME, GParamFlags.G_PARAM_PRIVATE";
    return super.toString();
  }
}

/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
final class _GParamSpec extends ffi.Struct {
  external GTypeInstance g_type_instance;

  external ffi.Pointer<gchar> name;

  @ffi.Int()
  external int flagsAsInt;

  GParamFlags get flags => GParamFlags.fromValue(flagsAsInt);

  @GType()
  external int value_type;

  @GType()
  external int owner_type;

  external ffi.Pointer<gchar> _nick;

  external ffi.Pointer<gchar> _blurb;

  external ffi.Pointer<GData> qdata;

  @guint()
  external int ref_count;

  @guint()
  external int param_id;
}

typedef GParamSpec = _GParamSpec;

/// GObjectConstructParam:
/// @pspec: the #GParamSpec of the construct parameter
/// @value: the value to set the parameter to
///
/// The GObjectConstructParam struct is an auxiliary structure used to hand
/// #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.
final class _GObjectConstructParam extends ffi.Struct {
  external ffi.Pointer<GParamSpec> pspec;

  external ffi.Pointer<GValue> value;
}

typedef GObjectConstructParam = _GObjectConstructParam;

/// GObjectClass:
/// @g_type_class: the parent class
/// @constructor: the @constructor function is called by g_object_new () to
/// complete the object initialization after all the construction properties are
/// set. The first thing a @constructor implementation must do is chain up to the
/// @constructor of the parent class. Overriding @constructor should be rarely
/// needed, e.g. to handle construct properties, or to implement singletons.
/// @set_property: the generic setter for all properties of this type. Should be
/// overridden for every type with properties. If implementations of
/// @set_property don't emit property change notification explicitly, this will
/// be done implicitly by the type system. However, if the notify signal is
/// emitted explicitly, the type system will not emit it a second time.
/// @get_property: the generic getter for all properties of this type. Should be
/// overridden for every type with properties.
/// @dispose: the @dispose function is supposed to drop all references to other
/// objects, but keep the instance otherwise intact, so that client method
/// invocations still work. It may be run multiple times (due to reference
/// loops). Before returning, @dispose should chain up to the @dispose method
/// of the parent class.
/// @finalize: instance finalization function, should finish the finalization of
/// the instance begun in @dispose and chain up to the @finalize method of the
/// parent class.
/// @dispatch_properties_changed: emits property change notification for a bunch
/// of properties. Overriding @dispatch_properties_changed should be rarely
/// needed.
/// @notify: the class closure for the notify signal
/// @constructed: the @constructed function is called by g_object_new() as the
/// final step of the object creation process.  At the point of the call, all
/// construction properties have been set on the object.  The purpose of this
/// call is to allow for object initialisation steps that can only be performed
/// after construction properties have been set.  @constructed implementors
/// should chain up to the @constructed call of their parent class to allow it
/// to complete its initialisation.
///
/// The class structure for the GObject type.
///
/// |[<!-- language="C" -->
/// // Example of implementing a singleton using a constructor.
/// static MySingleton *the_singleton = NULL;
///
/// static GObject*
/// my_singleton_constructor (GType                  type,
/// guint                  n_construct_params,
/// GObjectConstructParam *construct_params)
/// {
/// GObject *object;
///
/// if (!the_singleton)
/// {
/// object = G_OBJECT_CLASS (parent_class)->constructor (type,
/// n_construct_params,
/// construct_params);
/// the_singleton = MY_SINGLETON (object);
/// }
/// else
/// object = g_object_ref (G_OBJECT (the_singleton));
///
/// return object;
/// }
/// ]|
final class _GObjectClass extends ffi.Struct {
  external GTypeClass g_type_class;

  external ffi.Pointer<GSList$1> construct_properties;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<GObject> Function(
                  GType type,
                  guint n_construct_properties,
                  ffi.Pointer<GObjectConstructParam> construct_properties)>>
      constructor;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GObject> object,
              guint property_id,
              ffi.Pointer<GValue> value,
              ffi.Pointer<GParamSpec> pspec)>> set_property;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GObject> object,
              guint property_id,
              ffi.Pointer<GValue> value,
              ffi.Pointer<GParamSpec> pspec)>> get_property;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      dispose;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      finalize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<GObject> object, guint n_pspecs,
                  ffi.Pointer<ffi.Pointer<GParamSpec>> pspecs)>>
      dispatch_properties_changed;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<GObject> object, ffi.Pointer<GParamSpec> pspec)>>
      notify;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GObject> object)>>
      constructed;

  @gsize()
  external int flags;

  @ffi.Array.multi([6])
  external ffi.Array<gpointer> pdummy;
}

typedef GObjectClass = _GObjectClass;
typedef gssize = ffi.Long;
typedef Dartgssize = int;

final class _GInputStreamPrivate extends ffi.Opaque {}

typedef GInputStreamPrivate = _GInputStreamPrivate;

final class _GInputStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GInputStreamPrivate> priv;
}

typedef GInputStream = _GInputStream;

final class _GCancellablePrivate extends ffi.Opaque {}

typedef GCancellablePrivate = _GCancellablePrivate;

final class _GCancellable extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GCancellablePrivate> priv;
}

typedef GCancellable = _GCancellable;
typedef GAsyncReadyCallbackFunction = ffi.Void Function(
    ffi.Pointer<GObject> source_object,
    ffi.Pointer<GAsyncResult> res,
    gpointer user_data);
typedef DartGAsyncReadyCallbackFunction = void Function(
    ffi.Pointer<GObject> source_object,
    ffi.Pointer<GAsyncResult> res,
    gpointer user_data);

/// GAsyncReadyCallback:
/// @source_object: (nullable): the object the asynchronous operation was started with.
/// @res: a #GAsyncResult.
/// @user_data: user data passed to the callback.
///
/// Type definition for a function that will be called back when an asynchronous
/// operation within GIO has been completed. #GAsyncReadyCallback
/// callbacks from #GTask are guaranteed to be invoked in a later
/// iteration of the
/// [thread-default main context][g-main-context-push-thread-default]
/// where the #GTask was created. All other users of
/// #GAsyncReadyCallback must likewise call it asynchronously in a
/// later iteration of the main context.
///
/// The asynchronous operation is guaranteed to have held a reference to
/// @source_object from the time when the `*_async()` function was called, until
/// after this callback returns.
typedef GAsyncReadyCallback
    = ffi.Pointer<ffi.NativeFunction<GAsyncReadyCallbackFunction>>;

final class _GInputStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> skip;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> read_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> skip_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> skip_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GInputStream:
///
/// Base class for streaming input operations.
typedef GInputStreamClass = _GInputStreamClass;

final class _GBytes extends ffi.Opaque {}

typedef GBytes = _GBytes;

final class _GFilterInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

/// GFilterInputStream:
///
/// A base class for all input streams that work on an underlying stream.
typedef GFilterInputStreamClass = _GFilterInputStreamClass;

final class _GFilterInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GInputStream> base_stream;
}

typedef GFilterInputStream = _GFilterInputStream;

final class _GBufferedInputStreamPrivate extends ffi.Opaque {}

typedef GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;

final class _GBufferedInputStream extends ffi.Struct {
  external GFilterInputStream parent_instance;

  external ffi.Pointer<GBufferedInputStreamPrivate> priv;
}

typedef GBufferedInputStream = _GBufferedInputStream;

final class _GBufferedInputStreamClass extends ffi.Struct {
  external GFilterInputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GBufferedInputStream> stream,
              gssize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> fill;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GBufferedInputStream> stream,
              gssize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> fill_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GBufferedInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> fill_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GBufferedInputStream:
///
/// Implements #GFilterInputStream with a sized input buffer.
typedef GBufferedInputStreamClass = _GBufferedInputStreamClass;

final class _GOutputStreamPrivate extends ffi.Opaque {}

typedef GOutputStreamPrivate = _GOutputStreamPrivate;

final class _GOutputStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GOutputStreamPrivate> priv;
}

typedef GOutputStream = _GOutputStream;

/// GOutputStreamSpliceFlags:
/// @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after
/// the splice.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after
/// the splice.
///
/// GOutputStreamSpliceFlags determine how streams should be spliced.
enum GOutputStreamSpliceFlags {
  G_OUTPUT_STREAM_SPLICE_NONE(0),
  G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE(1),
  G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET(2);

  final int value;
  const GOutputStreamSpliceFlags(this.value);

  static GOutputStreamSpliceFlags fromValue(int value) => switch (value) {
        0 => G_OUTPUT_STREAM_SPLICE_NONE,
        1 => G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE,
        2 => G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,
        _ => throw ArgumentError(
            'Unknown value for GOutputStreamSpliceFlags: $value'),
      };
}

final class _GOutputVector extends ffi.Struct {
  external gconstpointer buffer;

  @gsize()
  external int size;
}

/// GOutputVector:
/// @buffer: Pointer to a buffer of data to read.
/// @size: the size of @buffer.
///
/// Structure used for scatter/gather data output.
/// You generally pass in an array of #GOutputVectors
/// and the operation will use all the buffers as if they were
/// one buffer.
///
/// Since: 2.22
typedef GOutputVector = _GOutputVector;

final class _GOutputStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GInputStream> source,
              ffi.UnsignedInt flags,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> splice;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> flush;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> write_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GInputStream> source,
              ffi.UnsignedInt flags,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> splice_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> splice_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> flush_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> flush_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> writev_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;
}

/// GOutputStream:
///
/// Base class for writing output.
///
/// All classes derived from GOutputStream should implement synchronous
/// writing, splicing, flushing and closing streams, but may implement
/// asynchronous versions.
typedef GOutputStreamClass = _GOutputStreamClass;

final class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

final class _GFilterOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;
}

/// GFilterOutputStream:
///
/// A base class for all output streams that work on an underlying stream.
typedef GFilterOutputStreamClass = _GFilterOutputStreamClass;

final class _GFilterOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GOutputStream> base_stream;
}

typedef GFilterOutputStream = _GFilterOutputStream;

final class _GBufferedOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;
}

/// GBufferedOutputStream:
///
/// An implementation of #GFilterOutputStream with a sized buffer.
typedef GBufferedOutputStreamClass = _GBufferedOutputStreamClass;

final class _GBufferedOutputStreamPrivate extends ffi.Opaque {}

typedef GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;

final class _GBufferedOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GBufferedOutputStreamPrivate> priv;
}

typedef GBufferedOutputStream = _GBufferedOutputStream;

final class _GConverterInputStreamClass extends ffi.Struct {
  external GFilterInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GConverterInputStream:
///
/// An implementation of #GFilterInputStream that allows data
/// conversion.
typedef GConverterInputStreamClass = _GConverterInputStreamClass;

final class _GConverterInputStreamPrivate extends ffi.Opaque {}

typedef GConverterInputStreamPrivate = _GConverterInputStreamPrivate;

final class _GConverterInputStream extends ffi.Struct {
  external GFilterInputStream parent_instance;

  external ffi.Pointer<GConverterInputStreamPrivate> priv;
}

final class _GConverter extends ffi.Opaque {}

typedef GConverter = _GConverter;
typedef GConverterInputStream = _GConverterInputStream;

final class _GConverterOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GConverterOutputStream:
///
/// An implementation of #GFilterOutputStream that allows data
/// conversion.
typedef GConverterOutputStreamClass = _GConverterOutputStreamClass;

final class _GConverterOutputStreamPrivate extends ffi.Opaque {}

typedef GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;

final class _GConverterOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GConverterOutputStreamPrivate> priv;
}

typedef GConverterOutputStream = _GConverterOutputStream;

final class _GDataInputStreamClass extends ffi.Struct {
  external GBufferedInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GDataInputStream:
///
/// An implementation of #GBufferedInputStream that allows for high-level
/// data manipulation of arbitrary data (including binary operations).
typedef GDataInputStreamClass = _GDataInputStreamClass;

final class _GDataInputStreamPrivate extends ffi.Opaque {}

typedef GDataInputStreamPrivate = _GDataInputStreamPrivate;

final class _GDataInputStream extends ffi.Struct {
  external GBufferedInputStream parent_instance;

  external ffi.Pointer<GDataInputStreamPrivate> priv;
}

typedef GDataInputStream = _GDataInputStream;

/// GDataStreamByteOrder:
/// @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.
///
/// #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
/// across various machine architectures.
enum GDataStreamByteOrder {
  G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN(0),
  G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN(1),
  G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN(2);

  final int value;
  const GDataStreamByteOrder(this.value);

  static GDataStreamByteOrder fromValue(int value) => switch (value) {
        0 => G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN,
        1 => G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN,
        2 => G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN,
        _ =>
          throw ArgumentError('Unknown value for GDataStreamByteOrder: $value'),
      };
}

/// GDataStreamNewlineType:
/// @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects "LF" line endings, common on most modern UNIX platforms.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects "CR" line endings.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects "CR, LF" line ending, common on Microsoft Windows.
/// @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.
///
/// #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
enum GDataStreamNewlineType {
  G_DATA_STREAM_NEWLINE_TYPE_LF(0),
  G_DATA_STREAM_NEWLINE_TYPE_CR(1),
  G_DATA_STREAM_NEWLINE_TYPE_CR_LF(2),
  G_DATA_STREAM_NEWLINE_TYPE_ANY(3);

  final int value;
  const GDataStreamNewlineType(this.value);

  static GDataStreamNewlineType fromValue(int value) => switch (value) {
        0 => G_DATA_STREAM_NEWLINE_TYPE_LF,
        1 => G_DATA_STREAM_NEWLINE_TYPE_CR,
        2 => G_DATA_STREAM_NEWLINE_TYPE_CR_LF,
        3 => G_DATA_STREAM_NEWLINE_TYPE_ANY,
        _ => throw ArgumentError(
            'Unknown value for GDataStreamNewlineType: $value'),
      };
}

typedef guchar = ffi.UnsignedChar;
typedef Dartguchar = int;
typedef gint16 = ffi.Short;
typedef Dartgint16 = int;
typedef gint32 = ffi.Int;
typedef Dartgint32 = int;

final class _GDataOutputStreamPrivate extends ffi.Opaque {}

typedef GDataOutputStreamPrivate = _GDataOutputStreamPrivate;

final class _GDataOutputStream extends ffi.Struct {
  external GFilterOutputStream parent_instance;

  external ffi.Pointer<GDataOutputStreamPrivate> priv;
}

/// GDataOutputStream:
///
/// An implementation of #GBufferedOutputStream that allows for high-level
/// data manipulation of arbitrary data (including binary operations).
typedef GDataOutputStream = _GDataOutputStream;

final class _GDataOutputStreamClass extends ffi.Struct {
  external GFilterOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

typedef GDataOutputStreamClass = _GDataOutputStreamClass;
typedef goffset = gint64;

final class _GFileInputStreamPrivate extends ffi.Opaque {}

typedef GFileInputStreamPrivate = _GFileInputStreamPrivate;

final class _GFileInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GFileInputStreamPrivate> priv;
}

typedef GFileInputStream = _GFileInputStream;

enum GSeekType {
  G_SEEK_CUR(0),
  G_SEEK_SET(1),
  G_SEEK_END(2);

  final int value;
  const GSeekType(this.value);

  static GSeekType fromValue(int value) => switch (value) {
        0 => G_SEEK_CUR,
        1 => G_SEEK_SET,
        2 => G_SEEK_END,
        _ => throw ArgumentError('Unknown value for GSeekType: $value'),
      };
}

final class _GFileInfo extends ffi.Opaque {}

typedef GFileInfo = _GFileInfo;

final class _GFileInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          goffset Function(ffi.Pointer<GFileInputStream> stream)>> tell;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GFileInputStream> stream)>> can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileInputStream> stream,
              goffset offset,
              ffi.UnsignedInt type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileInputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GFileInputStream:
///
/// A subclass of GInputStream for opened files. This adds
/// a few file-specific operations and seeking.
///
/// #GFileInputStream implements #GSeekable.
typedef GFileInputStreamClass = _GFileInputStreamClass;

final class _GIOStreamPrivate extends ffi.Opaque {}

typedef GIOStreamPrivate = _GIOStreamPrivate;

/// GIOStream:
///
/// Base class for read-write streams.
final class _GIOStream extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<GIOStreamPrivate> priv;
}

typedef GIOStream = _GIOStream;

final class _GIOStreamClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GInputStream> Function(
              ffi.Pointer<GIOStream> stream)>> get_input_stream;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GOutputStream> Function(
              ffi.Pointer<GIOStream> stream)>> get_output_stream;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> close_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GIOStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> close_finish;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved6;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved7;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved8;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved9;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved10;
}

typedef GIOStreamClass = _GIOStreamClass;

/// GIOStreamSpliceFlags:
/// @G_IO_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish
/// before calling the callback.
///
/// GIOStreamSpliceFlags determine how streams should be spliced.
///
/// Since: 2.28
enum GIOStreamSpliceFlags {
  G_IO_STREAM_SPLICE_NONE(0),
  G_IO_STREAM_SPLICE_CLOSE_STREAM1(1),
  G_IO_STREAM_SPLICE_CLOSE_STREAM2(2),
  G_IO_STREAM_SPLICE_WAIT_FOR_BOTH(4);

  final int value;
  const GIOStreamSpliceFlags(this.value);

  static GIOStreamSpliceFlags fromValue(int value) => switch (value) {
        0 => G_IO_STREAM_SPLICE_NONE,
        1 => G_IO_STREAM_SPLICE_CLOSE_STREAM1,
        2 => G_IO_STREAM_SPLICE_CLOSE_STREAM2,
        4 => G_IO_STREAM_SPLICE_WAIT_FOR_BOTH,
        _ =>
          throw ArgumentError('Unknown value for GIOStreamSpliceFlags: $value'),
      };
}

final class _GFileIOStreamPrivate extends ffi.Opaque {}

typedef GFileIOStreamPrivate = _GFileIOStreamPrivate;

final class _GFileIOStream extends ffi.Struct {
  external GIOStream parent_instance;

  external ffi.Pointer<GFileIOStreamPrivate> priv;
}

typedef GFileIOStream = _GFileIOStream;

final class _GFileIOStreamClass extends ffi.Struct {
  external GIOStreamClass parent_class;

  external ffi.Pointer<
          ffi
          .NativeFunction<goffset Function(ffi.Pointer<GFileIOStream> stream)>>
      tell;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFileIOStream> stream)>>
      can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileIOStream> stream,
              goffset offset,
              ffi.UnsignedInt type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
          ffi
          .NativeFunction<gboolean Function(ffi.Pointer<GFileIOStream> stream)>>
      can_truncate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileIOStream> stream,
              goffset size,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> truncate_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileIOStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GFileIOStream> stream)>> get_etag;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GFileIOStream:
///
/// A subclass of GIOStream for opened files. This adds
/// a few file-specific operations and seeking and truncating.
///
/// #GFileIOStream implements GSeekable.
typedef GFileIOStreamClass = _GFileIOStreamClass;

final class _GFileOutputStreamPrivate extends ffi.Opaque {}

typedef GFileOutputStreamPrivate = _GFileOutputStreamPrivate;

final class _GFileOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GFileOutputStreamPrivate> priv;
}

typedef GFileOutputStream = _GFileOutputStream;

final class _GFileOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          goffset Function(ffi.Pointer<GFileOutputStream> stream)>> tell;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GFileOutputStream> stream)>> can_seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileOutputStream> stream,
              goffset offset,
              ffi.UnsignedInt type,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> seek;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GFileOutputStream> stream)>>
      can_truncate;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(
              ffi.Pointer<GFileOutputStream> stream,
              goffset size,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> truncate_fn;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Pointer<GCancellable> cancellable,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<ffi.Char> attributes,
              ffi.Int io_priority,
              ffi.Pointer<GCancellable> cancellable,
              GAsyncReadyCallback callback,
              gpointer user_data)>> query_info_async;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GFileInfo> Function(
              ffi.Pointer<GFileOutputStream> stream,
              ffi.Pointer<GAsyncResult> result,
              ffi.Pointer<ffi.Pointer<GError>> error)>> query_info_finish;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GFileOutputStream> stream)>> get_etag;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GFileOutputStream:
///
/// A subclass of GOutputStream for opened files. This adds
/// a few file-specific operations and seeking and truncating.
///
/// #GFileOutputStream implements GSeekable.
typedef GFileOutputStreamClass = _GFileOutputStreamClass;

final class _GMemoryInputStreamClass extends ffi.Struct {
  external GInputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GMemoryInputStream:
///
/// Implements #GInputStream for arbitrary memory chunks.
typedef GMemoryInputStreamClass = _GMemoryInputStreamClass;

final class _GMemoryInputStreamPrivate extends ffi.Opaque {}

typedef GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;

final class _GMemoryInputStream extends ffi.Struct {
  external GInputStream parent_instance;

  external ffi.Pointer<GMemoryInputStreamPrivate> priv;
}

typedef GMemoryInputStream = _GMemoryInputStream;

final class _GMemoryOutputStreamClass extends ffi.Struct {
  external GOutputStreamClass parent_class;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved1;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved2;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved3;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved4;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> _g_reserved5;
}

/// GMemoryOutputStream:
///
/// Implements #GOutputStream for arbitrary memory chunks.
typedef GMemoryOutputStreamClass = _GMemoryOutputStreamClass;

final class _GMemoryOutputStreamPrivate extends ffi.Opaque {}

typedef GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;

final class _GMemoryOutputStream extends ffi.Struct {
  external GOutputStream parent_instance;

  external ffi.Pointer<GMemoryOutputStreamPrivate> priv;
}

typedef GReallocFuncFunction = gpointer Function(gpointer data, gsize size);
typedef DartGReallocFuncFunction = gpointer Function(
    gpointer data, Dartgsize size);

/// GReallocFunc:
/// @data: memory block to reallocate
/// @size: size to reallocate @data to
///
/// Changes the size of the memory block pointed to by @data to
/// @size bytes.
///
/// The function should have the same semantics as realloc().
///
/// Returns: a pointer to the reallocated memory
typedef GReallocFunc = ffi.Pointer<ffi.NativeFunction<GReallocFuncFunction>>;
typedef GMemoryOutputStream = _GMemoryOutputStream;

final class _GPollableInputStream extends ffi.Opaque {}

typedef GPollableInputStream = _GPollableInputStream;

/// GSource:
///
/// The `GSource` struct is an opaque data type
/// representing an event source.
typedef GSource = _GSource;
typedef GSourceFuncFunction = gboolean Function(gpointer user_data);
typedef DartGSourceFuncFunction = Dartgint Function(gpointer user_data);

/// GSourceFunc:
/// @user_data: data passed to the function, set when the source was
/// created with one of the above functions
///
/// Specifies the type of function passed to g_timeout_add(),
/// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
///
/// When calling g_source_set_callback(), you may need to cast a function of a
/// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
/// incompatible function types.
///
/// Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and
/// %G_SOURCE_REMOVE are more memorable names for the return value.
typedef GSourceFunc = ffi.Pointer<ffi.NativeFunction<GSourceFuncFunction>>;

final class _GSourceCallbackFuncs extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer cb_data)>>
      ref;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(gpointer cb_data)>>
      unref;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(gpointer cb_data, ffi.Pointer<GSource> source,
              ffi.Pointer<GSourceFunc> func, ffi.Pointer<gpointer> data)>> get$;
}

/// GSourceCallbackFuncs:
/// @ref: Called when a reference is added to the callback object
/// @unref: Called when a reference to the callback object is dropped
/// @get: Called to extract the callback function and data from the
/// callback object.
///
/// The `GSourceCallbackFuncs` struct contains
/// functions for managing callback objects.
typedef GSourceCallbackFuncs = _GSourceCallbackFuncs;
typedef GSourceDummyMarshalFunction = ffi.Void Function();
typedef DartGSourceDummyMarshalFunction = void Function();

/// GSourceDummyMarshal:
///
/// This is just a placeholder for #GClosureMarshal,
/// which cannot be used here for dependency reasons.
typedef GSourceDummyMarshal
    = ffi.Pointer<ffi.NativeFunction<GSourceDummyMarshalFunction>>;

final class _GSourceFuncs extends ffi.Struct {
  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(
                  ffi.Pointer<GSource> source, ffi.Pointer<gint> timeout_)>>
      prepare;

  external ffi.Pointer<
      ffi.NativeFunction<gboolean Function(ffi.Pointer<GSource> source)>> check;

  external ffi.Pointer<
      ffi.NativeFunction<
          gboolean Function(ffi.Pointer<GSource> source, GSourceFunc callback,
              gpointer user_data)>> dispatch;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GSource> source)>>
      finalize;

  external GSourceFunc closure_callback;

  external GSourceDummyMarshal closure_marshal;
}

/// GSourceFuncs:
/// @prepare: Called before all the file descriptors are polled. If the
/// source can determine that it is ready here (without waiting for the
/// results of the poll() call) it should return %TRUE. It can also return
/// a @timeout_ value which should be the maximum timeout (in milliseconds)
/// which should be passed to the poll() call. The actual timeout used will
/// be -1 if all sources returned -1, or it will be the minimum of all
/// the @timeout_ values returned which were >= 0.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE with a timeout of -1.  If @prepare returns a
/// timeout and the source also has a ready time set, then the
/// lower of the two will be used.
/// @check: Called after all the file descriptors are polled. The source
/// should return %TRUE if it is ready to be dispatched. Note that some
/// time may have passed since the previous prepare function was called,
/// so the source should be checked again here.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE.
/// @dispatch: Called to dispatch the event source, after it has returned
/// %TRUE in either its @prepare or its @check function, or if a ready time
/// has been reached. The @dispatch function receives a callback function and
/// user data. The callback function may be %NULL if the source was never
/// connected to a callback using g_source_set_callback(). The @dispatch
/// function should call the callback function with @user_data and whatever
/// additional parameters are needed for this type of event source. The
/// return value of the @dispatch function should be %G_SOURCE_REMOVE if the
/// source should be removed or %G_SOURCE_CONTINUE to keep it.
/// @finalize: Called when the source is finalized. At this point, the source
/// will have been destroyed, had its callback cleared, and have been removed
/// from its #GMainContext, but it will still have its final reference count,
/// so methods can be called on it from within this function.
///
/// The `GSourceFuncs` struct contains a table of
/// functions used to handle event sources in a generic manner.
///
/// For idle sources, the prepare and check functions always return %TRUE
/// to indicate that the source is always ready to be processed. The prepare
/// function also returns a timeout value of 0 to ensure that the poll() call
/// doesn't block (since that would be time wasted which could have been spent
/// running the idle function).
///
/// For timeout sources, the prepare and check functions both return %TRUE
/// if the timeout interval has expired. The prepare function also returns
/// a timeout value to ensure that the poll() call doesn't block too long
/// and miss the next timeout.
///
/// For file descriptor sources, the prepare function typically returns %FALSE,
/// since it must wait until poll() has been called before it knows whether
/// any events need to be processed. It sets the returned timeout to -1 to
/// indicate that it doesn't mind how long the poll() call blocks. In the
/// check function, it tests the results of the poll() call to see if the
/// required condition has been met, and returns %TRUE if so.
typedef GSourceFuncs = _GSourceFuncs;

final class _GMainContext extends ffi.Opaque {}

/// GMainContext:
///
/// The `GMainContext` struct is an opaque data
/// type representing a set of sources to be handled in a main loop.
typedef GMainContext = _GMainContext;

final class _GSourcePrivate extends ffi.Opaque {}

typedef GSourcePrivate = _GSourcePrivate;

final class _GSource extends ffi.Struct {
  external gpointer callback_data;

  external ffi.Pointer<GSourceCallbackFuncs> callback_funcs;

  external ffi.Pointer<GSourceFuncs> source_funcs;

  @guint()
  external int ref_count;

  external ffi.Pointer<GMainContext> context;

  @gint()
  external int priority;

  @guint()
  external int flags;

  @guint()
  external int source_id;

  external ffi.Pointer<GSList$1> poll_fds;

  external ffi.Pointer<GSource> prev;

  external ffi.Pointer<GSource> next;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<GSourcePrivate> priv;
}

/// GSource:
///
/// The `GSource` struct is an opaque data type
/// representing an event source.
typedef GSource$1 = _GSource;

/// GPollableInputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableInputStream instance is actually pollable
/// @is_readable: Checks if the stream is readable
/// @create_source: Creates a #GSource to poll the stream
/// @read_nonblocking: Does a non-blocking read or returns
/// %G_IO_ERROR_WOULD_BLOCK
///
/// The interface for pollable input streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @read_nonblocking calls
/// g_pollable_input_stream_is_readable(), and then calls
/// g_input_stream_read() if it returns %TRUE. This means you only need
/// to override it if it is possible that your @is_readable
/// implementation may return %TRUE when the stream is not actually
/// readable.
///
/// Since: 2.28
final class _GPollableInputStreamInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream> stream)>>
      can_poll;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableInputStream> stream)>>
      is_readable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSource$1> Function(
              ffi.Pointer<GPollableInputStream> stream,
              ffi.Pointer<GCancellable> cancellable)>> create_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GPollableInputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<ffi.Pointer<GError>> error)>> read_nonblocking;
}

/// GPollableInputStream:
///
/// An interface for a #GInputStream that can be polled for readability.
///
/// Since: 2.28
typedef GPollableInputStreamInterface = _GPollableInputStreamInterface;

final class _GPollableOutputStream extends ffi.Opaque {}

typedef GPollableOutputStream = _GPollableOutputStream;

/// GPollableReturn:
/// @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.
/// @G_POLLABLE_RETURN_OK: The operation was successfully finished.
/// @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.
///
/// Return value for various IO operations that signal errors via the
/// return value and not necessarily via a #GError.
///
/// This enum exists to be able to return errors to callers without having to
/// allocate a #GError. Allocating #GErrors can be quite expensive for
/// regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
///
/// In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
/// operation to give details about the error that happened.
///
/// Since: 2.60
enum GPollableReturn {
  G_POLLABLE_RETURN_FAILED(0),
  G_POLLABLE_RETURN_OK(1),
  G_POLLABLE_RETURN_WOULD_BLOCK(-27);

  final int value;
  const GPollableReturn(this.value);

  static GPollableReturn fromValue(int value) => switch (value) {
        0 => G_POLLABLE_RETURN_FAILED,
        1 => G_POLLABLE_RETURN_OK,
        -27 => G_POLLABLE_RETURN_WOULD_BLOCK,
        _ => throw ArgumentError('Unknown value for GPollableReturn: $value'),
      };
}

/// GPollableOutputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableOutputStream instance is actually pollable
/// @is_writable: Checks if the stream is writable
/// @create_source: Creates a #GSource to poll the stream
/// @write_nonblocking: Does a non-blocking write or returns
/// %G_IO_ERROR_WOULD_BLOCK
/// @writev_nonblocking: Does a vectored non-blocking write, or returns
/// %G_POLLABLE_RETURN_WOULD_BLOCK
///
/// The interface for pollable output streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @write_nonblocking calls
/// g_pollable_output_stream_is_writable(), and then calls
/// g_output_stream_write() if it returns %TRUE. This means you only
/// need to override it if it is possible that your @is_writable
/// implementation may return %TRUE when the stream is not actually
/// writable.
///
/// The default implementation of @writev_nonblocking calls
/// g_pollable_output_stream_write_nonblocking() for each vector, and converts
/// its return value and error (if set) to a #GPollableReturn. You should
/// override this where possible to avoid having to allocate a #GError to return
/// %G_IO_ERROR_WOULD_BLOCK.
///
/// Since: 2.28
final class _GPollableOutputStreamInterface extends ffi.Struct {
  external GTypeInterface g_iface;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream> stream)>>
      can_poll;

  external ffi.Pointer<
          ffi.NativeFunction<
              gboolean Function(ffi.Pointer<GPollableOutputStream> stream)>>
      is_writable;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<GSource$1> Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<GCancellable> cancellable)>> create_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          gssize Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<ffi.Void> buffer,
              gsize count,
              ffi.Pointer<ffi.Pointer<GError>> error)>> write_nonblocking;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<GPollableOutputStream> stream,
              ffi.Pointer<GOutputVector> vectors,
              gsize n_vectors,
              ffi.Pointer<gsize> bytes_written,
              ffi.Pointer<ffi.Pointer<GError>> error)>> writev_nonblocking;
}

/// GPollableOutputStream:
///
/// An interface for a #GOutputStream that can be polled for writeability.
///
/// Since: 2.28
typedef GPollableOutputStreamInterface = _GPollableOutputStreamInterface;

final class _GSimpleAsyncResultClass extends ffi.Opaque {}

/// GSimpleAsyncResult:
///
/// A simple implementation of #GAsyncResult.
typedef GSimpleAsyncResultClass = _GSimpleAsyncResultClass;

final class _GSimpleAsyncResult extends ffi.Opaque {}

typedef GSimpleAsyncResult = _GSimpleAsyncResult;
typedef GSimpleAsyncThreadFuncFunction = ffi.Void Function(
    ffi.Pointer<GSimpleAsyncResult> res,
    ffi.Pointer<GObject> object,
    ffi.Pointer<GCancellable> cancellable);
typedef DartGSimpleAsyncThreadFuncFunction = void Function(
    ffi.Pointer<GSimpleAsyncResult> res,
    ffi.Pointer<GObject> object,
    ffi.Pointer<GCancellable> cancellable);

/// GSimpleAsyncThreadFunc:
/// @res: a #GSimpleAsyncResult.
/// @object: a #GObject.
/// @cancellable: optional #GCancellable object, %NULL to ignore.
///
/// Simple thread function that runs an asynchronous operation and
/// checks for cancellation.
typedef GSimpleAsyncThreadFunc
    = ffi.Pointer<ffi.NativeFunction<GSimpleAsyncThreadFuncFunction>>;

final class _WpObjectManager extends ffi.Opaque {}

typedef WpObjectManager = _WpObjectManager;

final class _WpCore extends ffi.Opaque {}

typedef WpCore = _WpCore;

final class WpCoreClass extends ffi.Struct {
  external GObjectClass parent_class;
}

typedef WpCore_autoptr = ffi.Pointer<WpCore>;
typedef GList = _GList;

final class _GList extends ffi.Struct {
  external gpointer data;

  external ffi.Pointer<GList> next;

  external ffi.Pointer<GList> prev;
}

typedef GList$1 = _GList;
typedef WpCore_listautoptr = ffi.Pointer<GList$1>;
typedef WpCore_slistautoptr = ffi.Pointer<GSList$1>;

/// GQueue:
/// @head: a pointer to the first element of the queue
/// @tail: a pointer to the last element of the queue
/// @length: the number of elements in the queue
///
/// Contains the public fields of a
/// [Queue][glib-Double-ended-Queues].
final class _GQueue extends ffi.Struct {
  external ffi.Pointer<GList$1> head;

  external ffi.Pointer<GList$1> tail;

  @guint()
  external int length;
}

typedef GQueue = _GQueue;
typedef WpCore_queueautoptr = ffi.Pointer<GQueue>;
typedef WpCoreClass_autoptr = ffi.Pointer<WpCoreClass>;
typedef WpCoreClass_listautoptr = ffi.Pointer<GList$1>;
typedef WpCoreClass_slistautoptr = ffi.Pointer<GSList$1>;
typedef WpCoreClass_queueautoptr = ffi.Pointer<GQueue>;

final class _WpProperties extends ffi.Opaque {}

typedef WpProperties = _WpProperties;

final class _GVariant extends ffi.Opaque {}

typedef GVariant = _GVariant;

/// GClosure:
/// @in_marshal: Indicates whether the closure is currently being invoked with
/// g_closure_invoke()
/// @is_invalid: Indicates whether the closure has been invalidated by
/// g_closure_invalidate()
///
/// A #GClosure represents a callback supplied by the programmer.
final class _GClosure extends ffi.Opaque {}

typedef GClosure = _GClosure;

/// !
/// \brief Flags to be used as WpObjectFeatures on WpPlugin subclasses.
/// \ingroup wpplugin
enum WpPluginFeatures {
  /// ! enables the plugin
  WP_PLUGIN_FEATURE_ENABLED(1);

  final int value;
  const WpPluginFeatures(this.value);

  static WpPluginFeatures fromValue(int value) => switch (value) {
        1 => WP_PLUGIN_FEATURE_ENABLED,
        _ => throw ArgumentError('Unknown value for WpPluginFeatures: $value'),
      };
}

final class _WpObject extends ffi.Struct {
  external GObject parent_instance;
}

typedef WpObject = _WpObject;

final class _WpPlugin extends ffi.Struct {
  external WpObject parent_instance;
}

typedef WpPlugin = _WpPlugin;

/// !
/// \brief Flags that specify functionality that is available on this class.
///
/// Use wp_object_activate() to enable more features,
/// wp_object_get_supported_features() to see which features are supported and
/// wp_object_get_active_features() to find out which features are already
/// enabled. Features can also be deactivated later using wp_object_deactivate().
///
/// Actual feature flags are to be specified by subclasses and their interfaces.
/// WP_OBJECT_FEATURES_ALL is a special value that can be used to activate
/// all the supported features in any given object.
///
/// \ingroup wpobject
typedef WpObjectFeatures = guint;

final class _WpFeatureActivationTransition extends ffi.Opaque {}

typedef WpFeatureActivationTransition = _WpFeatureActivationTransition;

final class _WpObjectClass extends ffi.Struct {
  external GObjectClass parent_class;

  external ffi.Pointer<
          ffi.NativeFunction<
              WpObjectFeatures Function(ffi.Pointer<WpObject> self)>>
      get_supported_features;

  external ffi.Pointer<
      ffi.NativeFunction<
          guint Function(
              ffi.Pointer<WpObject> self,
              ffi.Pointer<WpFeatureActivationTransition> transition,
              guint step,
              WpObjectFeatures missing)>> activate_get_next_step;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WpObject> self,
              ffi.Pointer<WpFeatureActivationTransition> transition,
              guint step,
              WpObjectFeatures missing)>> activate_execute_step;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<WpObject> self, WpObjectFeatures features)>>
      deactivate;

  @ffi.Array.multi([8])
  external ffi.Array<gpointer> _wp_padding;
}

typedef WpObjectClass = _WpObjectClass;

final class _WpTransition extends ffi.Struct {
  external GObject parent_instance;
}

typedef WpTransition = _WpTransition;

final class _WpPluginClass extends ffi.Struct {
  external WpObjectClass parent_class;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<WpPlugin> self,
              ffi.Pointer<WpTransition> transition)>> enable;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WpPlugin> self)>>
      disable;

  @ffi.Array.multi([6])
  external ffi.Array<gpointer> _wp_padding;
}

typedef WpPluginClass = _WpPluginClass;
typedef WpPlugin_autoptr = ffi.Pointer<WpPlugin>;
typedef WpPlugin_listautoptr = ffi.Pointer<GList$1>;
typedef WpPlugin_slistautoptr = ffi.Pointer<GSList$1>;
typedef WpPlugin_queueautoptr = ffi.Pointer<GQueue>;
typedef WpPluginClass_autoptr = ffi.Pointer<WpPluginClass>;
typedef WpPluginClass_listautoptr = ffi.Pointer<GList$1>;
typedef WpPluginClass_slistautoptr = ffi.Pointer<GSList$1>;
typedef WpPluginClass_queueautoptr = ffi.Pointer<GQueue>;

/// !
/// \ingroup wp
/// Flags for wp_init()
enum WpInitFlags {
  /// ! Initialize PipeWire by calling pw_init()
  WP_INIT_PIPEWIRE(1),

  /// ! Initialize support for dynamic spa types.
  /// See wp_spa_dynamic_type_init()
  WP_INIT_SPA_TYPES(2),

  /// ! Override PipeWire's logging system with WirePlumber's one
  WP_INIT_SET_PW_LOG(4),

  /// ! Set wp_log_writer_default() as GLib's default log writer function
  WP_INIT_SET_GLIB_LOG(8),

  /// ! Initialize all of the above
  WP_INIT_ALL(15);

  final int value;
  const WpInitFlags(this.value);

  static WpInitFlags fromValue(int value) => switch (value) {
        1 => WP_INIT_PIPEWIRE,
        2 => WP_INIT_SPA_TYPES,
        4 => WP_INIT_SET_PW_LOG,
        8 => WP_INIT_SET_GLIB_LOG,
        15 => WP_INIT_ALL,
        _ => throw ArgumentError('Unknown value for WpInitFlags: $value'),
      };
}

/// !
/// \brief Flags to specify lookup directories
/// \ingroup wp
enum WpLookupDirs {
  /// !< $WIREPLUMBER_CONFIG_DIR
  WP_LOOKUP_DIR_ENV_CONFIG(1),

  /// !< $WIREPLUMBER_DATA_DIR
  WP_LOOKUP_DIR_ENV_DATA(2),

  /// !< XDG_CONFIG_HOME/wireplumber
  WP_LOOKUP_DIR_XDG_CONFIG_HOME(1024),

  /// !< ($prefix)/etc/wireplumber
  WP_LOOKUP_DIR_ETC(2048),

  /// !< $prefix/share/wireplumber
  WP_LOOKUP_DIR_PREFIX_SHARE(4096);

  final int value;
  const WpLookupDirs(this.value);

  static WpLookupDirs fromValue(int value) => switch (value) {
        1 => WP_LOOKUP_DIR_ENV_CONFIG,
        2 => WP_LOOKUP_DIR_ENV_DATA,
        1024 => WP_LOOKUP_DIR_XDG_CONFIG_HOME,
        2048 => WP_LOOKUP_DIR_ETC,
        4096 => WP_LOOKUP_DIR_PREFIX_SHARE,
        _ => throw ArgumentError('Unknown value for WpLookupDirs: $value'),
      };
}

final class _WpIterator extends ffi.Opaque {}

typedef WpIterator = _WpIterator;

const int _BITS_SIGCONTEXT_H = 1;

const int FP_XSTATE_MAGIC1 = 1179670611;

const int FP_XSTATE_MAGIC2 = 1179670597;

const int FP_XSTATE_MAGIC2_SIZE = 4;

const int _SYS_UCONTEXT_H = 1;

const int __NGREG = 23;

const int NGREG = 23;

const int SPA_DICT_FLAG_SORTED = 1;

const int SPA_VERSION_HANDLE = 0;

const int SPA_VERSION_HANDLE_FACTORY = 1;

const String SPA_HANDLE_FACTORY_ENUM_FUNC_NAME = 'spa_handle_factory_enum';

const String SPA_KEY_FACTORY_NAME = 'factory.name';

const String SPA_KEY_FACTORY_AUTHOR = 'factory.author';

const String SPA_KEY_FACTORY_DESCRIPTION = 'factory.description';

const String SPA_KEY_FACTORY_USAGE = 'factory.usage';

const String SPA_KEY_LIBRARY_NAME = 'library.name';

const String PW_TYPE_INTERFACE_Core = 'PipeWire:Interface:Core';

const String PW_TYPE_INTERFACE_Registry = 'PipeWire:Interface:Registry';

const int PW_VERSION_CORE = 3;

const int PW_VERSION_REGISTRY = 3;

const String PW_DEFAULT_REMOTE = 'pipewire-0';

const int PW_ID_CORE = 0;

const int PW_ID_ANY = 4294967295;

const int PW_CORE_CHANGE_MASK_PROPS = 1;

const int PW_CORE_CHANGE_MASK_ALL = 1;

const int PW_CORE_EVENT_INFO = 0;

const int PW_CORE_EVENT_DONE = 1;

const int PW_CORE_EVENT_PING = 2;

const int PW_CORE_EVENT_ERROR = 3;

const int PW_CORE_EVENT_REMOVE_ID = 4;

const int PW_CORE_EVENT_BOUND_ID = 5;

const int PW_CORE_EVENT_ADD_MEM = 6;

const int PW_CORE_EVENT_REMOVE_MEM = 7;

const int PW_CORE_EVENT_NUM = 8;

const int PW_VERSION_CORE_EVENTS = 0;

const int PW_CORE_METHOD_ADD_LISTENER = 0;

const int PW_CORE_METHOD_HELLO = 1;

const int PW_CORE_METHOD_SYNC = 2;

const int PW_CORE_METHOD_PONG = 3;

const int PW_CORE_METHOD_ERROR = 4;

const int PW_CORE_METHOD_GET_REGISTRY = 5;

const int PW_CORE_METHOD_CREATE_OBJECT = 6;

const int PW_CORE_METHOD_DESTROY = 7;

const int PW_CORE_METHOD_NUM = 8;

const int PW_VERSION_CORE_METHODS = 0;

const int PW_REGISTRY_EVENT_GLOBAL = 0;

const int PW_REGISTRY_EVENT_GLOBAL_REMOVE = 1;

const int PW_REGISTRY_EVENT_NUM = 2;

const int PW_VERSION_REGISTRY_EVENTS = 0;

const int PW_REGISTRY_METHOD_ADD_LISTENER = 0;

const int PW_REGISTRY_METHOD_BIND = 1;

const int PW_REGISTRY_METHOD_DESTROY = 2;

const int PW_REGISTRY_METHOD_NUM = 3;

const int PW_VERSION_REGISTRY_METHODS = 0;

const int PW_VERSION_CONTEXT_EVENTS = 0;

const int PW_VERSION_MAIN_LOOP_EVENTS = 0;

const int PW_VERSION_STREAM_EVENTS = 2;

const int SPA_ASYNC_BIT = 1073741824;

const int SPA_ASYNC_SEQ_MASK = 1073741823;

const int SPA_ASYNC_MASK = -1073741824;

const int SPA_VIDEO_MAX_PLANES = 4;

const int SPA_VIDEO_MAX_COMPONENTS = 4;

const int G_HOOK_FLAG_USER_SHIFT = 4;

const int _GETOPT_CORE_H = 1;
